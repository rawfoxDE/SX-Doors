/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : [r]FoX
 */

#include <exec/types.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>

#include <proto/all.h>
#include <proto/reqtools.h>
#include <proto/gadtools.h>
#include <string.h>

#include <pragmas/exec_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/gadtools_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/utility_pragmas.h>

#include "MenuEd_gui.h"

struct Screen         *Scr = NULL;
UBYTE                 *PubScreenName = NULL;
APTR                   VisualInfo = NULL;
struct Window         *Project5Wnd = NULL;
struct Gadget         *Project5GList = NULL;
struct IntuiMessage    Project5Msg;
struct Gadget         *Project5Gadgets[6];
UWORD                  Project5Left = 14;
UWORD                  Project5Top = 15;
UWORD                  Project5Width = 402;
UWORD                  Project5Height = 384;
UBYTE                 *Project5Wdt = (UBYTE *)"SX-CursorMenu-Editor";

extern struct MinList MainMenu0List;

struct Node MainMenu0Nodes[] = {
	( struct Node * )&MainMenu0List.mlh_Tail, ( struct Node * )&MainMenu0List.mlh_Head, 0, 0, "(new)" };

struct MinList MainMenu0List = {
	( struct MinNode * )&MainMenu0Nodes[0], ( struct MinNode * )NULL, ( struct MinNode * )&MainMenu0Nodes[0] };

extern struct MinList Commands0List;

struct Node Commands0Nodes[] = {
	( struct Node * )&Commands0List.mlh_Tail, ( struct Node * )&Commands0List.mlh_Head, 0, 0, "(new)" };

struct MinList Commands0List = {
	( struct MinNode * )&Commands0Nodes[0], ( struct MinNode * )NULL, ( struct MinNode * )&Commands0Nodes[0] };

struct TextAttr topaz8 = {
	( STRPTR )"topaz.font", 8, 0x00, 0x01 };

UWORD Project5GTypes[] = {
	LISTVIEW_KIND,
	LISTVIEW_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND
};

struct NewGadget Project5NGad[] = {
	14, 14, 161, 216, (UBYTE *)"MainMenu", NULL, GD_MainMenu, PLACETEXT_ABOVE, NULL, (APTR)MainMenuClicked,
	188, 15, 177, 216, (UBYTE *)"Commands", NULL, GD_Commands, PLACETEXT_ABOVE, NULL, (APTR)CommandsClicked,
	12, 229, 161, 13, (UBYTE *)"ADD", NULL, GD_AddMenu, PLACETEXT_IN, NULL, (APTR)AddMenuClicked,
	188, 229, 177, 13, (UBYTE *)"ADD", NULL, GD_AddCom, PLACETEXT_IN, NULL, (APTR)AddComClicked,
	12, 243, 161, 13, (UBYTE *)"DEL", NULL, GD_DelMenu, PLACETEXT_IN, NULL, (APTR)DelMenuClicked,
	188, 243, 177, 13, (UBYTE *)"DEL", NULL, GD_DelCom, PLACETEXT_IN, NULL, (APTR)DelComClicked
};

ULONG Project5GTags[] = {
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE)
};

int SetupScreen( void )
{
	if ( ! ( Scr = LockPubScreen( PubScreenName )))
		return( 1L );

	if ( ! ( VisualInfo = GetVisualInfo( Scr, TAG_DONE )))
		return( 2L );

	return( 0L );
}

void CloseDownScreen( void )
{
	if ( VisualInfo ) {
		FreeVisualInfo( VisualInfo );
		VisualInfo = NULL;
	}

	if ( Scr        ) {
		UnlockPubScreen( NULL, Scr );
		Scr = NULL;
	}
}

int HandleProject5IDCMP( void )
{
	struct IntuiMessage	*m;
	int			(*func)();
	BOOL			running = TRUE;

	while( m = GT_GetIMsg( Project5Wnd->UserPort )) {

		CopyMem(( char * )m, ( char * )&Project5Msg, (long)sizeof( struct IntuiMessage ));

		GT_ReplyIMsg( m );

		switch ( Project5Msg.Class ) {

			case	IDCMP_REFRESHWINDOW:
				GT_BeginRefresh( Project5Wnd );
				GT_EndRefresh( Project5Wnd, TRUE );
				break;

			case	IDCMP_CLOSEWINDOW:
				running = Project5CloseWindow();
				break;

			case	IDCMP_GADGETUP:
			case	IDCMP_GADGETDOWN:
				func = ( void * )(( struct Gadget * )Project5Msg.IAddress )->UserData;
				running = func();
				break;
		}
	}
	return( running );
}

int OpenProject5Window( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		offx = Scr->WBorLeft, offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

	if ( ! ( g = CreateContext( &Project5GList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < Project5_CNT; lc++ ) {

		CopyMem((char * )&Project5NGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = &topaz8;
		ng.ng_LeftEdge  += offx;
		ng.ng_TopEdge   += offy;

		Project5Gadgets[ lc ] = g = CreateGadgetA((ULONG)Project5GTypes[ lc ], g, &ng, ( struct TagItem * )&Project5GTags[ tc ] );

		while( Project5GTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	if ( ! ( Project5Wnd = OpenWindowTags( NULL,
				WA_Left,	Project5Left,
				WA_Top,		Project5Top,
				WA_Width,	Project5Width,
				WA_Height,	Project5Height + offy,
				WA_IDCMP,	LISTVIEWIDCMP|BUTTONIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
				WA_Flags,	WFLG_SIZEGADGET|WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH,
				WA_Gadgets,	Project5GList,
				WA_Title,	Project5Wdt,
				WA_PubScreen,	Scr,
				WA_MinWidth,	67,
				WA_MinHeight,	21,
				WA_MaxWidth,	1336,
				WA_MaxHeight,	554,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( Project5Wnd, NULL );

	return( 0L );
}

void CloseProject5Window( void )
{
	if ( Project5Wnd        ) {
		CloseWindow( Project5Wnd );
		Project5Wnd = NULL;
	}

	if ( Project5GList      ) {
		FreeGadgets( Project5GList );
		Project5GList = NULL;
	}
}

