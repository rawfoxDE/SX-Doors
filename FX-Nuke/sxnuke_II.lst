
;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 1
;
;
;Line#  Block                                  Source
;  1          /*
;  2
;  3          SX NUKER
;  4
;  5          */
;  6
;  7       0  #include <time.h>
;===> Including file "sc:include/time.h"
;  1.001      /* Copyright (c) 1992-1993 SAS Institute, Inc., Cary, NC USA */
;  1.002      /* All Rights Reserved */
;  1.003
;  1.004   0  #ifndef _TIME_H
;  1.005   0  #define _TIME_H 1
;  1.006
;  1.007   0  #ifndef _COMMNULL_H
;  1.008   0  #include <sys/commnull.h>
;===> Including file "sc:include/sys/commnull.h"
;  2.001      /* Copyright (c) 1993 SAS Institute, Inc., Cary, NC USA */
;  2.002      /* All Rights Reserved */
;  2.003
;  2.004      /* This header file contains common preprocessor symbol   */
;  2.005      /* definitions that were previously duplicated throughout */
;  2.006      /* the header files. Those definitions were moved here    */
;  2.007      /* and replaced with a #include of this header file.      */
;  2.008      /* This was done to purify the header files for GST       */
;  2.009      /* processing.                                            */
;  2.010
;  2.011   0  #ifndef NULL
;  2.012   0  #define NULL  0L
;  2.013   0  #endif
;  1.009   0  #endif
;  1.010
;  1.011   0  #ifndef _COMMSIZE_H
;  1.012   0  #include <sys/commsize.h>
;===> Including file "sc:include/sys/commsize.h"
;  3.001      /* Copyright (c) 1993 SAS Institute, Inc., Cary, NC USA */
;  3.002      /* All Rights Reserved */
;  3.003
;  3.004      /* This header file contains common preprocessor symbol   */
;  3.005      /* definitions that were previously duplicated throughout */
;  3.006      /* the header files. Those definitions were moved here    */
;  3.007      /* and replaced with a #include of this header file.      */
;  3.008      /* This was done to purify the header files for GST       */
;  3.009      /* processing.                                            */
;  3.010
;  3.011   0  #ifndef _SIZE_T
;  3.012   0  #define _SIZE_T 1
;  3.013   0  typedef unsigned int size_t;
;  3.014   0  #endif
;  1.013   0  #endif

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 2
;
;
;Line#  Block                                  Source
;  1.014
;  1.015   0  #ifndef _COMMTIME_H
;  1.016   0  #include <sys/commtime.h>
;===> Including file "sc:include/sys/commtime.h"
;  4.001      /* Copyright (c) 1993 SAS Institute, Inc., Cary, NC USA */
;  4.002      /* All Rights Reserved */
;  4.003
;  4.004      /* This header file contains common preprocessor symbol   */
;  4.005      /* definitions that were previously duplicated throughout */
;  4.006      /* the header files. Those definitions were moved here    */
;  4.007      /* and replaced with a #include of this header file.      */
;  4.008      /* This was done to purify the header files for GST       */
;  4.009      /* processing.                                            */
;  4.010
;  4.011   0  #ifndef _TIME_T
;  4.012   0  #define _TIME_T 1
;  4.013   0  typedef long time_t;
;  4.014   0  #endif
;  1.017   0  #endif
;  1.018
;  1.019   0  #define CLOCKS_PER_SEC  1000
;  1.020   0  #define CLK_TCK  CLOCKS_PER_SEC
;  1.021
;  1.022   0  typedef unsigned long clock_t;
;  1.023
;  1.024      /**
;  1.025      *
;  1.026      * This structure contains the unpacked time as returned by "gmtime".
;  1.027      *
;  1.028      */
;  1.029
;  1.030   0  struct tm {
;  1.031   0      int tm_sec;      /* seconds after the minute */
;  1.032   0      int tm_min;          /* minutes after the hour */
;  1.033   0      int tm_hour;         /* hours since midnight */
;  1.034   0      int tm_mday;         /* day of the month */
;  1.035   0      int tm_mon;          /* months since January */
;  1.036   0      int tm_year;         /* years since 1900 */
;  1.037   0      int tm_wday;         /* days since Sunday */
;  1.038   0      int tm_yday;         /* days since January 1 */
;  1.039   0      int tm_isdst;        /* Daylight Savings Time flag */
;  1.040   0  };
;  1.041
;  1.042
;  1.043      /***
;  1.044      *
;  1.045      *     ANSI time functions.
;  1.046      *
;  1.047      ***/
;  1.048

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 3
;
;
;Line#  Block                                  Source
;  1.049   0  extern clock_t clock(void);
;  1.050   0  extern double difftime(time_t, time_t);
;  1.051   0  extern time_t mktime(struct tm *);
;  1.052   0  extern time_t time(time_t *);
;  1.053
;  1.054   0  extern char *asctime(const struct tm *);
;  1.055   0  extern char *ctime(const time_t *);
;  1.056   0  extern struct tm *gmtime(const time_t *);
;  1.057   0  extern struct tm *localtime(const time_t *);
;  1.058   0  extern size_t strftime(char *, size_t, const char *, const struct tm *);
;  1.059
;  1.060
;  1.061   0  #ifndef _STRICT_ANSI
;  1.062
;  1.063      /***
;  1.064      *
;  1.065      *     SAS time functions
;  1.066      *
;  1.067      ***/
;  1.068
;  1.069   0  void getclk(unsigned char *);
;  1.070   0  int  chgclk(const unsigned char *);
;  1.071
;  1.072   0  void utunpk(long, char *);
;  1.073   0  long utpack(const char *);
;  1.074   0  int timer(unsigned int *);
;  1.075   0  int datecmp(const struct DateStamp *, const struct DateStamp *);
;  1.076
;  1.077   0  time_t __datecvt(const struct DateStamp *);
;  1.078   0  struct DateStamp *__timecvt(time_t);
;  1.079
;  1.080      /* for UNIX compatibility */
;  1.081   0  extern void      __tzset(void);
;  1.082   0  #define timezone __timezone
;  1.083   0  #define tzname   __tzname
;  1.084   0  #define daylight __daylight
;  1.085   0  #define tzset    __tzset
;  1.086
;  1.087
;  1.088   0  #define TZ  "CST6"      /* Used if TZ env. var. is not set */
;  1.089   0  #define DAY0  4         /* Jan 1, 1970 is a Thursday */
;  1.090
;  1.091   0  #endif /* _STRICT_ANSI */
;  1.092
;  1.093      /***
;  1.094      *     SAS external variables
;  1.095      ***/
;  1.096
;  1.097   0  extern int  __daylight;
;  1.098   0  extern long __timezone;

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 4
;
;
;Line#  Block                                  Source
;  1.099   0  extern char *__tzname[2];
;  1.100   0  extern char __tzstn[4];
;  1.101   0  extern char __tzdtn[4];
;  1.102   0  extern char *_TZ;
;  1.103
;  1.104
;  1.105   0  #endif
;  8       0  #include <stdio.h>
;===> Including file "sc:include/stdio.h"
;  5.001      /* Copyright (c) 1992-1993 SAS Institute, Inc., Cary, NC USA */
;  5.002      /* All Rights Reserved */
;  5.003
;  5.004
;  5.005   0  #ifndef _STDIO_H
;  5.006   0  #define _STDIO_H 1
;  5.007
;  5.008   0  #ifndef _COMMSIZE_H
;  5.009   0  #include <sys/commsize.h>
;  5.010   0  #endif
;  5.011
;  5.012   0  #ifndef _COMMLIST_H
;  5.013   0  #include <sys/commlist.h>
;===> Including file "sc:include/sys/commlist.h"
;  6.001      /* Copyright (c) 1993 SAS Institute, Inc., Cary, NC USA */
;  6.002      /* All Rights Reserved */
;  6.003
;  6.004      /* This header file contains common preprocessor symbol   */
;  6.005      /* definitions that were previously duplicated throughout */
;  6.006      /* the header files. Those definitions were moved here    */
;  6.007      /* and replaced with a #include of this header file.      */
;  6.008      /* This was done to purify the header files for GST       */
;  6.009      /* processing.                                            */
;  6.010
;  6.011   0  #ifndef _VA_LIST
;  6.012   0  #define _VA_LIST 1
;  6.013   0  typedef char *va_list;
;  6.014   0  #endif
;  5.014   0  #endif
;  5.015
;  5.016   0  typedef unsigned long fpos_t;
;  5.017
;  5.018   0  #ifndef _COMMNULL_H
;  5.019   0  #include <sys/commnull.h>
;  5.020   0  #endif
;  5.021
;  5.022      /**
;  5.023      *
;  5.024      * Definitions associated with __iobuf._flag
;  5.025      *
;  5.026      **/

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 5
;
;
;Line#  Block                                  Source
;  5.027
;  5.028   0  #define _IOFBF   0		/* fully buffered (for setvbuf) */
;  5.029   0  #define _IOREAD  1		/* read flag */
;  5.030   0  #define _IOWRT   2		/* write flag */
;  5.031   0  #define _IONBF   4		/* non-buffered flag */
;  5.032   0  #define _IOMYBUF 8		/* private buffer flag */
;  5.033   0  #define _IOEOF   16		/* end-of-file flag */
;  5.034   0  #define _IOERR   32		/* error flag */
;  5.035   0  #define _IOLBF   64		/* line-buffered flag */
;  5.036   0  #define _IORW    128		/* read-write (update) flag */
;  5.037   0  #define _IOUNGET 0x1000         /* unget was used since last seek */
;  5.038   0  #define _IORKEY  0x2000         /* raw console I/O flag */
;  5.039   0  #define _IOAPP   0x4000		/* append flag */
;  5.040   0  #define _IOXLAT  0x8000		/* translation flag */
;  5.041
;  5.042   0  #define BUFSIZ 512		/* standard buffer size */
;  5.043   0  #define EOF (-1)		/* end-of-file code */
;  5.044   0  #define FOPEN_MAX 20            /* maximum number of open files */
;  5.045   0  #define FILENAME_MAX  64        /* maximum filename length */
;  5.046   0  #define L_tmpnam 64             /* maximum tmpnam filename length */
;  5.047
;  5.048   0  #define SEEK_SET 0              /* Seek from beginning of file */
;  5.049   0  #define SEEK_CUR 1              /* Seek from current file position */
;  5.050   0  #define SEEK_END 2              /* Seek from end of file */
;  5.051
;  5.052   0  #define TMP_MAX 999             /* Guaranteed unique temp names */
;  5.053
;  5.054   0  struct __iobuf {
;  5.055   0      struct __iobuf *_next;
;  5.056   0      unsigned char *_ptr;	/* current buffer pointer */
;  5.057   0      int _rcnt;		        /* current byte count for reading */
;  5.058   0      int _wcnt;		        /* current byte count for writing */
;  5.059   0      unsigned char *_base;	/* base address of I/O buffer */
;  5.060   0      int _size;			/* size of buffer */
;  5.061   0      int _flag;	        	/* control flags */
;  5.062   0      int _file;		        /* file descriptor */
;  5.063   0      unsigned char _cbuff;	/* single char buffer */
;  5.064   0  };
;  5.065
;  5.066   0  typedef struct __iobuf FILE;
;  5.067
;  5.068   0  extern struct __iobuf __iob[];
;  5.069
;  5.070   0  #define stdin (&__iob[0])	/* standard input file pointer */
;  5.071   0  #define stdout (&__iob[1])	/* standard output file pointer */
;  5.072   0  #define stderr (&__iob[2])	/* standard error file pointer */
;  5.073
;  5.074
;  5.075      /***
;  5.076      *

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 6
;
;
;Line#  Block                                  Source
;  5.077      *     Prototypes for ANSI standard functions.
;  5.078      *
;  5.079      ***/
;  5.080
;  5.081
;  5.082   0  extern int remove(const char *);
;  5.083   0  extern int rename(const char *, const char *);
;  5.084   0  extern FILE *tmpfile(void);
;  5.085   0  extern char *tmpnam(char *s);
;  5.086
;  5.087   0  extern int fclose(FILE *);
;  5.088   0  extern int fflush(FILE *);
;  5.089   0  extern FILE *fopen(const char *, const char *);
;  5.090   0  extern FILE *freopen(const char *, const char *, FILE *);
;  5.091   0  extern void setbuf(FILE *, char *);
;  5.092   0  extern int setvbuf(FILE *, char *, int, size_t);
;  5.093
;  5.094   0  extern int fprintf(FILE *, const char *, ...);
;  5.095   0  extern int fscanf(FILE *, const char *, ...);
;  5.096   0  extern int printf(const char *, ...);
;  5.097   0  extern int __builtin_printf(const char *, ...);
;  5.098   0  extern int scanf(const char *, ...);
;  5.099   0  extern int sprintf(char *, const char *, ...);
;  5.100   0  extern int sscanf(const char *, const char *, ...);
;  5.101   0  extern int vfprintf(FILE *, const char *, va_list);
;  5.102   0  extern int vprintf(const char *, va_list);
;  5.103   0  extern int vsprintf(char *, const char *, va_list);
;  5.104
;  5.105   0  extern int fgetc(FILE *);
;  5.106   0  extern char *fgets(char *, int, FILE *);
;  5.107   0  extern int fputc(int, FILE *);
;  5.108   0  extern int fputs(const char *, FILE *);
;  5.109   0  extern int getc(FILE *);
;  5.117   0              fgetc(p))
;  5.118   0  extern int getchar(void);
;  5.119   0  #define getchar() getc(stdin)
;  5.120   0  extern char *gets(char *);
;  5.121   0  extern int putc(int, FILE *);
;  5.122
;  5.123   0  #ifdef _USE_DIRTY_PUTC
;  5.124      /* this putc macro evaluates the charater expression multiple time */
;  5.125      /* which is a violation of the ANSI standard. */
;  5.137                   fputc(c,p))
;  5.138      #endif
;  5.139
;  5.140
;  5.141   0  extern int putchar(int);
;  5.142   0  #define putchar(c) putc(c,stdout)
;  5.143   0  extern int puts(const char *);
;  5.144   0  extern int ungetc(int, FILE *);

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 7
;
;
;Line#  Block                                  Source
;  5.145
;  5.146   0  extern size_t fread(void *, size_t, size_t, FILE *);
;  5.147   0  extern size_t fwrite(const void *, size_t, size_t, FILE *);
;  5.148   0  extern int fgetpos(FILE *, fpos_t *);
;  5.149   0  extern int fseek(FILE *, long int, int);
;  5.150   0  extern int fsetpos(FILE *, const fpos_t *);
;  5.151   0  extern long int ftell(FILE *);
;  5.152   0  extern void rewind(FILE *);
;  5.153   0  #define rewind(p) fseek(p, 0L, 0)
;  5.154
;  5.155   0  extern void clearerr(FILE *);
;  5.156   0  #define clearerr(p) ((p)->_flag &= ~(_IOERR | _IOEOF))
;  5.157   0  extern int feof(FILE *);
;  5.158   0  #define feof(p) (((p)->_flag & _IOEOF) != 0)
;  5.159   0  extern int ferror(FILE *);
;  5.160   0  #define ferror(p) (((p)->_flag & _IOERR) != 0)
;  5.161   0  extern void perror(const char *);
;  5.162
;  5.163   0  #define printf __builtin_printf
;  5.164
;  5.165   0  #ifndef _STRICT_ANSI
;  5.166
;  5.167      /* defines for mode of access() */
;  5.168   0  #define R_OK 4
;  5.169   0  #define W_OK 2
;  5.170   0  #define X_OK 1
;  5.171   0  #define F_OK 0
;  5.172
;  5.173      /***
;  5.174      *
;  5.175      *     Prototypes for Non-ANSI functions.
;  5.176      *
;  5.177      ***/
;  5.178
;  5.179   0  extern int __io2errno(int);
;  5.180   0  extern int fcloseall(void);
;  5.181   0  extern FILE *fdopen(int, const char *);
;  5.182   0  extern int fhopen(long, int);
;  5.183   0  extern int fgetchar(void);
;  5.184   0  extern int fileno(FILE *);
;  5.185   0  extern int flushall(void);
;  5.186   0  extern void fmode(FILE *, int);
;  5.187   0  extern int _writes(const char *, ...);
;  5.188   0  extern int _tinyprintf(char *, ...);
;  5.189   0  extern int fputchar(int);
;  5.190   0  extern void setnbf(FILE *);
;  5.191   0  extern int __fillbuff(FILE *);
;  5.192   0  extern int __flushbuff(int, FILE *);
;  5.193   0  extern int __access(const char *, int);
;  5.194   0  extern int access(const char *, int);

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 8
;
;
;Line#  Block                                  Source
;  5.195   0  extern int chdir(const char *);
;  5.196   0  extern int chmod(const char *, int);
;  5.197   0  extern char *getcwd(char *, int);
;  5.198   0  extern int unlink(const char *);
;  5.199   0  extern int poserr(const char *);
;  5.200
;  5.201   0  #define  clrerr  clearerr
;  5.202   0  #define  access  __access
;  5.203   0  #define  _filbf  __fillbuff
;  5.204   0  #define  fileno(p) ((p)->_file)
;  5.205   0  #define  _flsbf  __flushbuff
;  5.206
;  5.207
;  5.208      /***
;  5.209      *
;  5.210      *     The following routines allow for raw console I/O.
;  5.211      *
;  5.212      ***/
;  5.213
;  5.214   0  int rawcon(int);
;  5.215   0  int getch(void);
;  5.216
;  5.217   0  #endif /* _STRICT_ANSI */
;  5.218
;  5.219   0  extern unsigned long __fmask;
;  5.220   0  extern int __fmode;
;  5.221
;  5.222   0  #endif
;  9       0  #include <string.h>
;===> Including file "sc:include/string.h"
;  7.001      /* Copyright (c) 1992-1993 SAS Institute, Inc., Cary, NC USA */
;  7.002      /* All Rights Reserved */
;  7.003
;  7.004   0  #ifndef _STRING_H
;  7.005   0  #define _STRING_H 1
;  7.006
;  7.007   0  #ifndef _COMMSIZE_H
;  7.008   0  #include <sys/commsize.h>
;  7.009   0  #endif
;  7.010
;  7.011   0  #ifndef _COMMNULL_H
;  7.012   0  #include <sys/commnull.h>
;  7.013   0  #endif
;  7.014
;  7.015      /***
;  7.016      *
;  7.017      *     ANSI copying functions
;  7.018      *
;  7.019      ***/
;  7.020

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 9
;
;
;Line#  Block                                  Source
;  7.021   0  extern void *memcpy(void *, const void *, size_t);
;  7.022   0  extern void *memmove(void *, const void *, size_t);
;  7.023   0  extern char *strcpy(char *, const char *);
;  7.024   0  extern char *strncpy(char *, const char *, size_t);
;  7.025
;  7.026
;  7.027      /***
;  7.028      *
;  7.029      *     ANSI concatenation functions
;  7.030      *
;  7.031      ***/
;  7.032
;  7.033   0  extern char *strcat(char *, const char *);
;  7.034   0  extern char *strncat(char *, const char *, size_t);
;  7.035
;  7.036
;  7.037      /***
;  7.038      *
;  7.039      *     ANSI comparison functions
;  7.040      *
;  7.041      ***/
;  7.042
;  7.043   0  extern int memcmp(const void *, const void *, size_t);
;  7.044   0  extern int strcmp(const char *, const char *);
;  7.045   0  extern int strcoll(const char *, const char *);
;  7.046   0  extern int strncmp(const char *, const char *, size_t);
;  7.047   0  extern size_t strxfrm(char *, const char *, size_t);
;  7.048
;  7.049
;  7.050      /***
;  7.051      *
;  7.052      *     ANSI search functions
;  7.053      *
;  7.054      ***/
;  7.055
;  7.056   0  extern void *memchr(const void *, int, size_t);
;  7.057   0  extern char *strchr(const char *, int);
;  7.058   0  extern size_t strcspn(const char *, const char *);
;  7.059   0  extern char *strpbrk(const char *, const char *);
;  7.060   0  extern char *strrchr(const char *, int);
;  7.061   0  extern size_t strspn(const char *, const char *);
;  7.062   0  extern char *strstr(const char *, const char *);
;  7.063   0  extern char *strtok(char *, const char *);
;  7.064
;  7.065
;  7.066      /***
;  7.067      *
;  7.068      *     ANSI miscellaneous functions
;  7.069      *
;  7.070      ***/

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 10
;
;
;Line#  Block                                  Source
;  7.071
;  7.072   0  extern void *memset(void *, int, size_t);
;  7.073   0  extern char *strerror(int);
;  7.074   0  extern size_t strlen(const char *);
;  7.075
;  7.076   0  #ifndef _STRICT_ANSI
;  7.077
;  7.078      /***
;  7.079      *
;  7.080      *     SAS string and memory functions.
;  7.081      *
;  7.082      ***/
;  7.083
;  7.084   0  extern int stcarg(const char *, const char *);
;  7.085   0  extern int stccpy(char *, const char *, int);
;  7.086   0  extern int stcgfe(char *, const char *);
;  7.087   0  extern int stcgfn(char *, const char *);
;  7.088   0  extern int stcis(const char *, const char *);
;  7.089   0  extern int stcisn(const char *, const char *);
;  7.090   0  extern int __stcd_i(const char *, int *);
;  7.091   0  extern int __stcd_l(const char *, long *);
;  7.092   0  extern int stch_i(const char *, int *);
;  7.093   0  extern int stch_l(const char *, long *);
;  7.094   0  extern int stci_d(char *, int);
;  7.095   0  extern int stci_h(char *, int);
;  7.096   0  extern int stci_o(char *, int);
;  7.097   0  extern int stcl_d(char *, long);
;  7.098   0  extern int __stcl_h(char *, long);
;  7.099   0  extern int __stcl_o(char *, long);
;  7.100   0  extern int stco_i(const char *, int *);
;  7.101   0  extern int stco_l(const char *, long *);
;  7.102   0  extern int stcpm(const char *, const char *, char **);
;  7.103   0  extern int stcpma(const char *, const char *);
;  7.104   0  extern int stcsma(const char *, const char *);
;  7.105   0  extern int astcsma(const char *, const char *);
;  7.106   0  extern int stcu_d(char *, unsigned);
;  7.107   0  extern int __stcul_d(char *, unsigned long);
;  7.108
;  7.109   0  #define stclen(a) strlen(a)
;  7.110
;  7.111   0  extern char *stpblk(const char *);
;  7.112   0  extern char *stpbrk(const char *, const char *);
;  7.113   0  extern char *stpchr(const char *, int);
;  7.114   0  extern char *stpcpy(char *, const char *);
;  7.115   0  extern char *__stpcpy(char *, const char *);
;  7.116   0  extern char *stpdate(char *, int, const char *);
;  7.117   0  extern char *stpsym(const char *, char *, int);
;  7.118   0  extern char *stptime(char *, int, const char *);
;  7.119   0  extern char *stptok(const char *, char *, int, const char *);
;  7.120

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 11
;
;
;Line#  Block                                  Source
;  7.121   0  extern int strbpl(char **, int, const char *);
;  7.122   0  extern int stricmp(const char *, const char *);
;  7.123   0  extern char *strdup(const char *);
;  7.124   0  extern void strins(char *, const char *);
;  7.125   0  extern int strmid(const char *, char *, int, int);
;  7.126   0  extern char *__strlwr(char *);
;  7.127   0  extern void strmfe(char *, const char *, const char *);
;  7.128   0  extern void strmfn(char *, const char *, const char *, const char *,
;  7.129   0                     const char *);
;  7.130   0  extern void strmfp(char *, const char *, const char *);
;  7.131   0  extern int strnicmp(const char *, const char *, size_t);
;  7.132   0  extern char *strnset(char *, int, int);
;  7.133
;  7.134   0  extern char *stpchrn(const char *, int);
;  7.135   0  extern char *strrev(char *);
;  7.136   0  extern char *strset(char *, int);
;  7.137   0  extern void strsfn(const char *, char *, char *, char *, char *);
;  7.138   0  extern char *__strupr(char *);
;  7.139   0  extern int stspfp(char *, int *);
;  7.140   0  extern void strsrt(char *[], int);
;  7.141
;  7.142   0  extern int stcgfp(char *, const char *);
;  7.143
;  7.144   0  #define strcmpi stricmp		/* For Microsoft compatibility */
;  7.145   0  #define strlwr  __strlwr
;  7.146   0  #define strupr  __strupr
;  7.147   0  #define stcd_i __stcd_i
;  7.148   0  #define stcd_l __stcd_l
;  7.149   0  #define stcl_h __stcl_h
;  7.150   0  #define stcl_o __stcl_o
;  7.151   0  #define stcul_d __stcul_d
;  7.152   0  #define stpcpy __stpcpy
;  7.153
;  7.154   0  extern void *memccpy(void *, const void *, int, unsigned);
;  7.155   0  extern void movmem(const void *, void *, unsigned);
;  7.156   0  extern void repmem(void *, const void *, size_t, size_t);
;  7.157   0  extern void setmem(void *, unsigned, int);
;  7.158   0  extern void __swmem(void *, void *, unsigned);
;  7.159   0  #define swmem  __swmem
;  7.160
;  7.161      /* for BSD compatibility */
;  7.162   0  #ifndef __cplusplus
;  7.163   0  #define index(a,b) strchr(a,b)
;  7.164   0  #endif
;  7.165   0  #define rindex(a,b) strrchr(a,b)
;  7.166   0  #define bcopy(a,b,c) memmove(b,a,c)
;  7.167   0  #define bcmp(a,b,c) memcmp(a,b,c)
;  7.168   0  #define bzero(a,b) memset(a,0,b)
;  7.169
;  7.170   0  #endif /* _STRICT_ANSI */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 12
;
;
;Line#  Block                                  Source
;  7.171
;  7.172      /**
;  7.173      *
;  7.174      * Builtin function definitions
;  7.175      *
;  7.176      **/
;  7.177
;  7.178   0  extern size_t  __builtin_strlen(const char *);
;  7.179   0  extern int     __builtin_strcmp(const char *, const char *);
;  7.180   0  extern char   *__builtin_strcpy(char *, const char *);
;  7.181
;  7.182   0  extern void   *__builtin_memset(void *, int, size_t);
;  7.183   0  extern int     __builtin_memcmp(const void *, const void *, size_t);
;  7.184   0  extern void   *__builtin_memcpy(void *, const void *, size_t);
;  7.185
;  7.186   0  extern int __builtin_max(int, int);
;  7.187   0  extern int __builtin_min(int, int);
;  7.188   0  extern int __builtin_abs(int);
;  7.189
;  7.190   0  #ifdef USE_BUILTIN_MATH
;  7.191      /* if you want the builtin versions of abs(), max(), and min() */
;  7.192      /* define USE_BUITLIN_MATH, and #include this file BEFORE math.h */
;  7.193
;  7.194      #ifndef __cplusplus
;  7.195
;  7.196      #ifndef max
;  7.197      #define max(a,b) __builtin_max(a,b)
;  7.198      #endif
;  7.199
;  7.200      #ifndef min
;  7.201      #define min(a,b) __builtin_min(a,b)
;  7.202      #endif
;  7.203
;  7.204      #ifndef abs
;  7.205      #define abs(a) __builtin_abs(a)
;  7.206      #endif
;  7.207
;  7.208      #endif
;  7.209
;  7.210      #endif
;  7.211
;  7.212   0  #define strlen(a)   __builtin_strlen(a)
;  7.213   0  #define strcmp(a,b) __builtin_strcmp(a,b)
;  7.214   0  #define strcpy(a,b) __builtin_strcpy(a,b)
;  7.215
;  7.216   0  #define memset(a,b,c) __builtin_memset(a,b,c)
;  7.217   0  #define memcmp(a,b,c) __builtin_memcmp(a,b,c)
;  7.218   0  #define memcpy(a,b,c) __builtin_memcpy(a,b,c)
;  7.219
;  7.220

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 13
;
;
;Line#  Block                                  Source
;  7.221   0  #endif
; 10       0  #include <stdlib.h>
;===> Including file "sc:include/stdlib.h"
;  8.001      /* Copyright (c) 1992-1993 SAS Institute, Inc., Cary, NC USA */
;  8.002      /* All Rights Reserved */
;  8.003
;  8.004
;  8.005   0  #ifndef _STDLIB_H
;  8.006   0  #define _STDLIB_H 1
;  8.007
;  8.008   0  #ifndef _COMMSIZE_H
;  8.009   0  #include <sys/commsize.h>
;  8.010   0  #endif
;  8.011
;  8.012   0  #ifndef _COMMCHAR_H
;  8.013   0  #include <sys/commchar.h>
;===> Including file "sc:include/sys/commchar.h"
;  9.001      /* Copyright (c) 1993 SAS Institute, Inc., Cary, NC USA */
;  9.002      /* All Rights Reserved */
;  9.003
;  9.004      /* This header file contains common preprocessor symbol   */
;  9.005      /* definitions that were previously duplicated throughout */
;  9.006      /* the header files. Those definitions were moved here    */
;  9.007      /* and replaced with a #include of this header file.      */
;  9.008      /* This was done to purify the header files for GST       */
;  9.009      /* processing.                                            */
;  9.010
;  9.011   0  #ifndef _WCHAR_T
;  9.012   0  #define _WCHAR_T 1
;  9.013   0  typedef char wchar_t;
;  9.014   0  #endif
;  8.014   0  #endif
;  8.015
;  8.016   0  #ifndef _COMMNULL_H
;  8.017   0  #include <sys/commnull.h>
;  8.018   0  #endif
;  8.019
;  8.020   0  typedef struct {
;  8.021   0              int quot;
;  8.022   0              int rem;
;  8.023   0          } div_t;
;  8.024
;  8.025   0  typedef struct {
;  8.026   0              long int quot;
;  8.027   0              long int rem;
;  8.028   0          } ldiv_t;
;  8.029
;  8.030   0  #define EXIT_SUCCESS 0
;  8.031   0  #define EXIT_FAILURE 20
;  8.032

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 14
;
;
;Line#  Block                                  Source
;  8.033   0  #ifdef _SHORTINT
;  8.034      #define RAND_MAX   32767
;  8.035      #else
;  8.036   0  #define RAND_MAX   2147483647
;  8.037   0  #endif
;  8.038
;  8.039   0  #define MB_CUR_MAX  __mb_cur_max
;  8.040   0  extern char __mb_cur_max;
;  8.041
;  8.042   0  extern double atof(const char *);
;  8.043   0  extern int atoi(const char *);
;  8.044   0  extern long int atol(const char *);
;  8.045
;  8.046   0  extern double strtod(const char *, char **);
;  8.047   0  extern long int strtol(const char *, char **, int);
;  8.048   0  extern unsigned long int strtoul(const char *, char **, int);
;  8.049
;  8.050
;  8.051   0  extern int rand(void);
;  8.052   0  extern void srand(unsigned int);
;  8.053
;  8.054
;  8.055      /***
;  8.056      *
;  8.057      *     ANSI memory management functions
;  8.058      *
;  8.059      ***/
;  8.060
;  8.061   0  extern void *calloc(size_t, size_t);
;  8.062   0  extern void free(void *);
;  8.063   0  extern void *malloc(size_t);
;  8.064   0  extern void *realloc(void *, size_t);
;  8.065
;  8.066   0  #ifndef _STRICT_ANSI
;  8.067   0  extern void *halloc(unsigned long);              /*  Extension  */
;  8.068   0  extern void *__halloc(unsigned long);            /*  Extension  */
;  8.069   0  #endif /* _STRICT_ANSI */
;  8.070
;  8.071
;  8.072      /***
;  8.073      *
;  8.074      *     ANSI environment functions
;  8.075      *
;  8.076      ***/
;  8.077
;  8.078   0  extern void abort(void);
;  8.079   0  extern int atexit(void (*)(void));
;  8.080   0  extern void exit(int);
;  8.081   0  extern char *__getenv(const char *);
;  8.082   0  extern char *getenv(const char *);

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 15
;
;
;Line#  Block                                  Source
;  8.083   0  #define getenv __getenv
;  8.084   0  extern int system(const char *);
;  8.085
;  8.086
;  8.087      /***
;  8.088      *
;  8.089      *     ANSI searching and sorting functions
;  8.090      *
;  8.091      ***/
;  8.092
;  8.093   0  extern void *bsearch(const void *, const void *, size_t, size_t,
;  8.094   0                       int (*)(const void *, const void *));
;  8.095   0  extern void qsort(void *, size_t, size_t, int (*)(const void *, const void *));
;  8.096
;  8.097
;  8.098      /***
;  8.099      *
;  8.100      *     ANSI integer arithmetic functions
;  8.101      *
;  8.102      ***/
;  8.103   0  #ifndef __cplusplus
;  8.104   0  extern int abs(int);
;  8.105   0  #endif
;  8.106   0  extern div_t div(int, int);
;  8.107   0  extern long int labs(long int);
;  8.108   0  extern ldiv_t ldiv(long int, long int);
;  8.109
;  8.110
;  8.111      /***
;  8.112      *
;  8.113      *     ANSI multibyte character functions
;  8.114      *
;  8.115      ***/
;  8.116
;  8.117   0  extern int mblen(const char *, size_t);
;  8.118   0  extern int mbtowc(wchar_t *, const char *, size_t);
;  8.119   0  extern int wctomb(char *, wchar_t);
;  8.120   0  extern size_t mbstowcs(wchar_t *, const char *, size_t);
;  8.121   0  extern size_t wcstombs(char *, const wchar_t *, size_t);
;  8.122
;  8.123
;  8.124   0  #ifndef _STRICT_ANSI
;  8.125   0  #ifndef __cplusplus
;  8.126   0  #ifndef abs
;  8.127   0  #define abs(i)   ((i) < 0 ? -(i) : (i))
;  8.128   0  #endif
;  8.129   0  #endif
;  8.130
;  8.131   0  #ifndef labs
;  8.132   0  #define labs(i)  ((i) < 0 ? -(i) : (i))

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 16
;
;
;Line#  Block                                  Source
;  8.133   0  #endif
;  8.134
;  8.135      /***
;  8.136      *
;  8.137      *     SAS Level 2 memory allocation functions
;  8.138      *
;  8.139      ***/
;  8.140
;  8.141   0  extern void *getmem(unsigned int);
;  8.142   0  extern void *getml(long);
;  8.143   0  extern void rlsmem(void *, unsigned int);
;  8.144   0  extern void rlsml(void *, long);
;  8.145   0  extern int bldmem(int);
;  8.146   0  extern long sizmem(void);
;  8.147   0  extern long chkml(void);
;  8.148   0  extern void rstmem(void);
;  8.149
;  8.150
;  8.151      /***
;  8.152      *
;  8.153      *     SAS Level 1 memory allocation functions
;  8.154      *
;  8.155      ***/
;  8.156
;  8.157   0  extern void *sbrk(unsigned int);
;  8.158   0  extern void *lsbrk(long);
;  8.159   0  extern int rbrk(void);
;  8.160   0  extern void __stdargs _MemCleanup(void);
;  8.161
;  8.162   0  extern unsigned long _MemType;
;  8.163   0  extern void *_MemHeap;
;  8.164   0  extern unsigned long _MSTEP;
;  8.165
;  8.166
;  8.167      /**
;  8.168      *
;  8.169      * SAS Sort functions
;  8.170      *
;  8.171      */
;  8.172
;  8.173   0  extern void dqsort(double *, size_t);
;  8.174   0  extern void fqsort(float *, size_t);
;  8.175   0  extern void lqsort(long *, size_t);
;  8.176   0  extern void sqsort(short *, size_t);
;  8.177   0  extern void tqsort(char **, size_t);
;  8.178
;  8.179
;  8.180      /***
;  8.181      *
;  8.182      *     SAS startup, exit and environment functions.

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 17
;
;
;Line#  Block                                  Source
;  8.183      *
;  8.184      ***/
;  8.185
;  8.186   0  extern void __exit(int);
;  8.187   0  extern void __stdargs __main(char *);
;  8.188   0  extern void __stdargs __tinymain(char *);
;  8.189   0  extern void __stdargs _XCEXIT(long);
;  8.190   0  extern char *argopt(int, char**, char *, int *, char *);
;  8.191   0  extern int iabs(int);
;  8.192   0  extern int onexit(void (*)(void));
;  8.193   0  extern int putenv(const char *);
;  8.194
;  8.195   0  #define XCEXIT _XCEXIT                   /* compatibility with v5.0 */
;  8.196   0  #define _main __main
;  8.197   0  #define _exit __exit
;  8.198
;  8.199   0  #ifndef _COMMWBEN_H
;  8.200   0  #include <sys/commwben.h>
;===> Including file "sc:include/sys/commwben.h"
; 10.001      /* Copyright (c) 1993 SAS Institute, Inc., Cary, NC USA */
; 10.002      /* All Rights Reserved */
; 10.003
; 10.004      /* This header file contains common preprocessor symbol   */
; 10.005      /* definitions that were previously duplicated throughout */
; 10.006      /* the header files. Those definitions were moved here    */
; 10.007      /* and replaced with a #include of this header file.      */
; 10.008      /* This was done to purify the header files for GST       */
; 10.009      /* processing.                                            */
; 10.010
; 10.011   0  #ifndef WBenchMsg
; 10.013   0  extern struct WBStartup *_WBenchMsg;  /* WorkBench startup, if the */
; 10.014   0  #define WBenchMsg _WBenchMsg          /* program was started from  */
; 10.016   0  #endif
; 10.017
; 10.018      /* The following two externs give you the information in the   */
; 10.019      /* WBStartup structure parsed out to look like an (argc, argv) */
; 10.020      /* pair.  Don't define them in your code;  just include this   */
; 10.021      /* file and use them.  If the program was not run from         */
; 10.022      /* WorkBench, _WBArgc will be zero.                            */
; 10.023
; 10.024   0  extern int _WBArgc;    /* Count of the number of WorkBench arguments */
; 10.025   0  extern char **_WBArgv; /* The actual arguments                       */
;  8.201   0  #endif
;  8.202
;  8.203   0  #endif /* _STRICT_ANSI */
;  8.204
;  8.205   0  #endif
; 11       0  #include <exec/memory.h>
;===> Including file "sc:include/exec/memory.h"
; 11.001   0  #ifndef	EXEC_MEMORY_H

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 18
;
;
;Line#  Block                                  Source
; 11.002   0  #define	EXEC_MEMORY_H
; 11.003      /*
; 11.004      **	$VER: memory.h 39.3 (21.5.92)
; 11.005      **	Includes Release 40.13
; 11.006      **
; 11.007      **	Definitions and structures used by the memory allocation system
; 11.008      **
; 11.009      **	(C) Copyright 1985-1993 Commodore-Amiga, Inc.
; 11.010      **	    All Rights Reserved
; 11.011      */
; 11.012
; 11.013   0  #ifndef EXEC_NODES_H
; 11.014   0  #include "exec/nodes.h"
;===> Including file "sc:include/exec/nodes.h"
; 12.001   0  #ifndef	EXEC_NODES_H
; 12.002   0  #define	EXEC_NODES_H
; 12.003      /*
; 12.004      **	$VER: nodes.h 39.0 (15.10.91)
; 12.005      **	Includes Release 40.13
; 12.006      **
; 12.007      **	Nodes & Node type identifiers.
; 12.008      **
; 12.009      **	(C) Copyright 1985-1993 Commodore-Amiga, Inc.
; 12.010      **	    All Rights Reserved
; 12.011      */
; 12.012
; 12.013   0  #ifndef EXEC_TYPES_H
; 12.014   0  #include "exec/types.h"
;===> Including file "sc:include/exec/types.h"
; 13.001   0  #ifndef	EXEC_TYPES_H
; 13.002   0  #define	EXEC_TYPES_H
; 13.003      /*
; 13.004      **	$VER: types.h 40.1 (10.8.93)
; 13.005      **	Includes Release 40.13
; 13.006      **
; 13.007      **	Data typing.  Must be included before any other Amiga include.
; 13.008      **
; 13.009      **	(C) Copyright 1985-1993 Commodore-Amiga, Inc.
; 13.010      **	    All Rights Reserved
; 13.011      */
; 13.012
; 13.013
; 13.014   0  #define INCLUDE_VERSION	40 /* Version of the include files in use. (Do not
; 13.015   0  			      use this label for OpenLibrary() calls!) */
; 13.016
; 13.017
; 13.018   0  #define GLOBAL	extern	    /* the declaratory use of an external */
; 13.019   0  #define IMPORT	extern	    /* reference to an external */
; 13.020   0  #define STATIC	static	    /* a local static variable */
; 13.021   0  #define REGISTER register   /* a (hopefully) register variable */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 19
;
;
;Line#  Block                                  Source
; 13.022
; 13.023
; 13.024   0  #ifndef VOID
; 13.025   0  #define VOID		void
; 13.026   0  #endif
; 13.027
; 13.028
; 13.029        /*  WARNING: APTR was redefined for the V36 Includes!  APTR is a   */
; 13.030       /*  32-Bit Absolute Memory Pointer.  C pointer math will not	    */
; 13.031      /*  operate on APTR --	use "ULONG *" instead.			   */
; 13.032   0  #ifndef APTR_TYPEDEF
; 13.033   0  #define APTR_TYPEDEF
; 13.034   0  typedef void	       *APTR;	    /* 32-bit untyped pointer */
; 13.035   0  #endif
; 13.036   0  typedef long		LONG;	    /* signed 32-bit quantity */
; 13.037   0  typedef unsigned long	ULONG;	    /* unsigned 32-bit quantity */
; 13.038   0  typedef unsigned long	LONGBITS;   /* 32 bits manipulated individually */
; 13.039   0  typedef short		WORD;	    /* signed 16-bit quantity */
; 13.040   0  typedef unsigned short	UWORD;	    /* unsigned 16-bit quantity */
; 13.041   0  typedef unsigned short	WORDBITS;   /* 16 bits manipulated individually */
; 13.042   0  #if __STDC__
; 13.043   0  typedef signed char	BYTE;	    /* signed 8-bit quantity */
; 13.044   0  #else
; 13.045      typedef char		BYTE;	    /* signed 8-bit quantity */
; 13.046      #endif
; 13.047   0  typedef unsigned char	UBYTE;	    /* unsigned 8-bit quantity */
; 13.048   0  typedef unsigned char	BYTEBITS;   /* 8 bits manipulated individually */
; 13.049   0  typedef unsigned short	RPTR;	    /* signed relative pointer */
; 13.050
; 13.051   0  #ifdef __cplusplus
; 13.052      typedef char	       *STRPTR;     /* string pointer (NULL terminated) */
; 13.053      #else
; 13.054   0  typedef unsigned char  *STRPTR;     /* string pointer (NULL terminated) */
; 13.055   0  #endif
; 13.056
; 13.057
; 13.058      /* For compatibility only: (don't use in new code) */
; 13.059   0  typedef short		SHORT;	    /* signed 16-bit quantity (use WORD) */
; 13.060   0  typedef unsigned short	USHORT;     /* unsigned 16-bit quantity (use UWORD) */
; 13.061   0  typedef short		COUNT;
; 13.062   0  typedef unsigned short	UCOUNT;
; 13.063   0  typedef ULONG		CPTR;
; 13.064
; 13.065
; 13.066      /* Types with specific semantics */
; 13.067   0  typedef float		FLOAT;
; 13.068   0  typedef double		DOUBLE;
; 13.069   0  typedef short		BOOL;
; 13.070   0  typedef unsigned char	TEXT;
; 13.071

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 20
;
;
;Line#  Block                                  Source
; 13.072   0  #ifndef TRUE
; 13.073   0  #define TRUE		1
; 13.074   0  #endif
; 13.075   0  #ifndef FALSE
; 13.076   0  #define FALSE		0
; 13.077   0  #endif
; 13.078
; 13.079   0  #include <sys/commnull.h>
; 13.080
; 13.081
; 13.082   0  #define BYTEMASK	0xFF
; 13.083
; 13.084
; 13.085       /* #define LIBRARY_VERSION is now obsolete.  Please use LIBRARY_MINIMUM */
; 13.086      /* or code the specific minimum library version you require.		*/
; 13.087   0  #define LIBRARY_MINIMUM	33 /* Lowest version supported by Commodore-Amiga */
; 13.088
; 13.089
; 13.090   0  #endif	/* EXEC_TYPES_H */
; 12.015   0  #endif /* EXEC_TYPES_H */
; 12.016
; 12.017
; 12.018      /*
; 12.019       *  List Node Structure.  Each member in a list starts with a Node
; 12.020       */
; 12.021
; 12.022   0  struct Node {
; 12.023   0      struct  Node *ln_Succ;	/* Pointer to next (successor) */
; 12.024   0      struct  Node *ln_Pred;	/* Pointer to previous (predecessor) */
; 12.025   0      UBYTE   ln_Type;
; 12.026   0      BYTE    ln_Pri;		/* Priority, for sorting */
; 12.027   0      char    *ln_Name;		/* ID string, null terminated */
; 12.028   0  };	/* Note: word aligned */
; 12.029
; 12.030      /* minimal node -- no type checking possible */
; 12.031   0  struct MinNode {
; 12.032   0      struct MinNode *mln_Succ;
; 12.033   0      struct MinNode *mln_Pred;
; 12.034   0  };
; 12.035
; 12.036
; 12.037      /*
; 12.038      ** Note: Newly initialized IORequests, and software interrupt structures
; 12.039      ** used with Cause(), should have type NT_UNKNOWN.  The OS will assign a type
; 12.040      ** when they are first used.
; 12.041      */
; 12.042      /*----- Node Types for LN_TYPE -----*/
; 12.043   0  #define NT_UNKNOWN	0
; 12.044   0  #define NT_TASK		1	/* Exec task */
; 12.045   0  #define NT_INTERRUPT	2

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 21
;
;
;Line#  Block                                  Source
; 12.046   0  #define NT_DEVICE	3
; 12.047   0  #define NT_MSGPORT	4
; 12.048   0  #define NT_MESSAGE	5	/* Indicates message currently pending */
; 12.049   0  #define NT_FREEMSG	6
; 12.050   0  #define NT_REPLYMSG	7	/* Message has been replied */
; 12.051   0  #define NT_RESOURCE	8
; 12.052   0  #define NT_LIBRARY	9
; 12.053   0  #define NT_MEMORY	10
; 12.054   0  #define NT_SOFTINT	11	/* Internal flag used by SoftInits */
; 12.055   0  #define NT_FONT		12
; 12.056   0  #define NT_PROCESS	13	/* AmigaDOS Process */
; 12.057   0  #define NT_SEMAPHORE	14
; 12.058   0  #define NT_SIGNALSEM	15	/* signal semaphores */
; 12.059   0  #define NT_BOOTNODE	16
; 12.060   0  #define NT_KICKMEM	17
; 12.061   0  #define NT_GRAPHICS	18
; 12.062   0  #define NT_DEATHMESSAGE	19
; 12.063
; 12.064   0  #define NT_USER		254	/* User node types work down from here */
; 12.065   0  #define NT_EXTENDED	255
; 12.066
; 12.067   0  #endif	/* EXEC_NODES_H */
; 11.015   0  #endif /* EXEC_NODES_H */
; 11.016
; 11.017
; 11.018      /****** MemChunk ****************************************************/
; 11.019
; 11.020   0  struct	MemChunk {
; 11.021   0      struct  MemChunk *mc_Next;	/* pointer to next chunk */
; 11.022   0      ULONG   mc_Bytes;		/* chunk byte size	*/
; 11.023   0  };
; 11.024
; 11.025
; 11.026      /****** MemHeader ***************************************************/
; 11.027
; 11.028   0  struct	MemHeader {
; 11.029   0      struct  Node mh_Node;
; 11.030   0      UWORD   mh_Attributes;	/* characteristics of this region */
; 11.031   0      struct  MemChunk *mh_First; /* first free region		*/
; 11.032   0      APTR    mh_Lower;		/* lower memory bound		*/
; 11.033   0      APTR    mh_Upper;		/* upper memory bound+1	*/
; 11.034   0      ULONG   mh_Free;		/* total number of free bytes	*/
; 11.035   0  };
; 11.036
; 11.037
; 11.038      /****** MemEntry ****************************************************/
; 11.039
; 11.040   0  struct	MemEntry {
; 11.041   0  union {
; 11.042   0      ULONG   meu_Reqs;		/* the AllocMem requirements */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 22
;
;
;Line#  Block                                  Source
; 11.043   0      APTR    meu_Addr;		/* the address of this memory region */
; 11.044   0      } me_Un;
; 11.045   0      ULONG   me_Length;		/* the length of this memory region */
; 11.046   0  };
; 11.047
; 11.048   0  #define me_un	    me_Un	/* compatibility - do not use*/
; 11.049   0  #define me_Reqs     me_Un.meu_Reqs
; 11.050   0  #define me_Addr     me_Un.meu_Addr
; 11.051
; 11.052
; 11.053      /****** MemList *****************************************************/
; 11.054
; 11.055      /* Note: sizeof(struct MemList) includes the size of the first MemEntry! */
; 11.056   0  struct	MemList {
; 11.057   0      struct  Node ml_Node;
; 11.058   0      UWORD   ml_NumEntries;	/* number of entries in this struct */
; 11.059   0      struct  MemEntry ml_ME[1];	/* the first entry	*/
; 11.060   0  };
; 11.061
; 11.062   0  #define ml_me	ml_ME		/* compatability - do not use */
; 11.063
; 11.064
; 11.065      /*----- Memory Requirement Types ---------------------------*/
; 11.066      /*----- See the AllocMem() documentation for details--------*/
; 11.067
; 11.068   0  #define MEMF_ANY    (0L)	/* Any type of memory will do */
; 11.069   0  #define MEMF_PUBLIC (1L<<0)
; 11.070   0  #define MEMF_CHIP   (1L<<1)
; 11.071   0  #define MEMF_FAST   (1L<<2)
; 11.072   0  #define MEMF_LOCAL  (1L<<8)	/* Memory that does not go away at RESET */
; 11.073   0  #define MEMF_24BITDMA (1L<<9)	/* DMAable memory within 24 bits of address */
; 11.074   0  #define	MEMF_KICK   (1L<<10)	/* Memory that can be used for KickTags */
; 11.075
; 11.076   0  #define MEMF_CLEAR   (1L<<16)	/* AllocMem: NULL out area before return */
; 11.077   0  #define MEMF_LARGEST (1L<<17)	/* AvailMem: return the largest chunk size */
; 11.078   0  #define MEMF_REVERSE (1L<<18)	/* AllocMem: allocate from the top down */
; 11.079   0  #define MEMF_TOTAL   (1L<<19)	/* AvailMem: return total size of memory */
; 11.080
; 11.081   0  #define	MEMF_NO_EXPUNGE	(1L<<31) /*AllocMem: Do not cause expunge on failure */
; 11.082
; 11.083      /*----- Current alignment rules for memory blocks (may increase) -----*/
; 11.084   0  #define MEM_BLOCKSIZE	8L
; 11.085   0  #define MEM_BLOCKMASK	(MEM_BLOCKSIZE-1)
; 11.086
; 11.087
; 11.088      /****** MemHandlerData **********************************************/
; 11.089      /* Note:  This structure is *READ ONLY* and only EXEC can create it!*/
; 11.090   0  struct MemHandlerData
; 11.091   0  {
; 11.092   0  	ULONG	memh_RequestSize;	/* Requested allocation size */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 23
;
;
;Line#  Block                                  Source
; 11.093   0  	ULONG	memh_RequestFlags;	/* Requested allocation flags */
; 11.094   0  	ULONG	memh_Flags;		/* Flags (see below) */
; 11.095   0  };
; 11.096
; 11.097   0  #define	MEMHF_RECYCLE	(1L<<0)	/* 0==First time, 1==recycle */
; 11.098
; 11.099      /****** Low Memory handler return values ***************************/
; 11.100   0  #define	MEM_DID_NOTHING	(0)	/* Nothing we could do... */
; 11.101   0  #define	MEM_ALL_DONE	(-1)	/* We did all we could do */
; 11.102   0  #define	MEM_TRY_AGAIN	(1)	/* We did some, try the allocation again */
; 11.103
; 11.104   0  #endif	/* EXEC_MEMORY_H */
; 12       0  #include <proto/exec.h>
;===> Including file "sc:include/proto/exec.h"
; 14.001   0  #ifndef  PROTO_EXEC_H
; 14.002   0  #define  PROTO_EXEC_H
; 14.003
; 14.004   0  #include <exec/types.h>
; 14.005   0  #include <clib/exec_protos.h>
;===> Including file "sc:include/clib/exec_protos.h"
; 15.001   0  #ifndef  CLIB_EXEC_PROTOS_H
; 15.002   0  #define  CLIB_EXEC_PROTOS_H
; 15.003
; 15.004      /*
; 15.005      **	$VER: exec_protos.h 39.14 (15.2.93)
; 15.006      **	Includes Release 40.13
; 15.007      **
; 15.008      **	C prototypes. For use with 32 bit integers only.
; 15.009      **
; 15.010      **	(C) Copyright 1990-1993 Commodore-Amiga, Inc.
; 15.011      **	    All Rights Reserved
; 15.012      */
; 15.013
; 15.014   0  #ifndef  EXEC_TYPES_H
; 15.015      #include <exec/types.h>
; 15.016      #endif
; 15.017   0  #ifndef  EXEC_TASKS_H
; 15.018   0  #include <exec/tasks.h>
;===> Including file "sc:include/exec/tasks.h"
; 16.001   0  #ifndef	EXEC_TASKS_H
; 16.002   0  #define	EXEC_TASKS_H
; 16.003      /*
; 16.004      **	$VER: tasks.h 39.3 (18.9.92)
; 16.005      **	Includes Release 40.13
; 16.006      **
; 16.007      **	Task Control Block, Singals, and Task flags.
; 16.008      **
; 16.009      **	(C) Copyright 1985-1993 Commodore-Amiga, Inc.
; 16.010      **	    All Rights Reserved
; 16.011      */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 24
;
;
;Line#  Block                                  Source
; 16.012
; 16.013   0  #ifndef EXEC_NODES_H
; 16.014      #include "exec/nodes.h"
; 16.015      #endif /* EXEC_NODES_H */
; 16.016
; 16.017   0  #ifndef EXEC_LISTS_H
; 16.018   0  #include "exec/lists.h"
;===> Including file "sc:include/exec/lists.h"
; 17.001   0  #ifndef EXEC_LISTS_H
; 17.002   0  #define EXEC_LISTS_H
; 17.003      /*
; 17.004      **	$VER: lists.h 39.0 (15.10.91)
; 17.005      **	Includes Release 40.13
; 17.006      **
; 17.007      **	Definitions and macros for use with Exec lists
; 17.008      **
; 17.009      **	(C) Copyright 1985-1993 Commodore-Amiga, Inc.
; 17.010      **	    All Rights Reserved
; 17.011      */
; 17.012
; 17.013   0  #ifndef EXEC_NODES_H
; 17.014      #include "exec/nodes.h"
; 17.015      #endif /* EXEC_NODES_H */
; 17.016
; 17.017      /*
; 17.018       *  Full featured list header.
; 17.019       */
; 17.020   0  struct List {
; 17.021   0     struct  Node *lh_Head;
; 17.022   0     struct  Node *lh_Tail;
; 17.023   0     struct  Node *lh_TailPred;
; 17.024   0     UBYTE   lh_Type;
; 17.025   0     UBYTE   l_pad;
; 17.026   0  };	/* word aligned */
; 17.027
; 17.028      /*
; 17.029       * Minimal List Header - no type checking
; 17.030       */
; 17.031   0  struct MinList {
; 17.032   0     struct  MinNode *mlh_Head;
; 17.033   0     struct  MinNode *mlh_Tail;
; 17.034   0     struct  MinNode *mlh_TailPred;
; 17.035   0  };	/* longword aligned */
; 17.036
; 17.037
; 17.038      /*
; 17.039       *	Check for the presence of any nodes on the given list.	These
; 17.040       *	macros are even safe to use on lists that are modified by other
; 17.041       *	tasks.	However; if something is simultaneously changing the
; 17.042       *	list, the result of the test is unpredictable.

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 25
;
;
;Line#  Block                                  Source
; 17.043       *
; 17.044       *	Unless you first arbitrated for ownership of the list, you can't
; 17.045       *	_depend_ on the contents of the list.  Nodes might have been added
; 17.046       *	or removed during or after the macro executes.
; 17.047       *
; 17.048       *		if( IsListEmpty(list) )		printf("List is empty\n");
; 17.049       */
; 17.051   0  	( ((x)->lh_TailPred) == (struct Node *)(x) )
; 17.052
; 17.054   0  	( ((x)->mp_MsgList.lh_TailPred) == (struct Node *)(&(x)->mp_MsgList) )
; 17.055
; 17.056
; 17.057   0  #endif	/* EXEC_LISTS_H */
; 16.019   0  #endif /* EXEC_LISTS_H */
; 16.020
; 16.021
; 16.022      /* Please use Exec functions to modify task structure fields, where available.
; 16.023       */
; 16.024   0  struct Task {
; 16.025   0      struct  Node tc_Node;
; 16.026   0      UBYTE   tc_Flags;
; 16.027   0      UBYTE   tc_State;
; 16.028   0      BYTE    tc_IDNestCnt;	    /* intr disabled nesting*/
; 16.029   0      BYTE    tc_TDNestCnt;	    /* task disabled nesting*/
; 16.030   0      ULONG   tc_SigAlloc;	    /* sigs allocated */
; 16.031   0      ULONG   tc_SigWait;	    /* sigs we are waiting for */
; 16.032   0      ULONG   tc_SigRecvd;	    /* sigs we have received */
; 16.033   0      ULONG   tc_SigExcept;	    /* sigs we will take excepts for */
; 16.034   0      UWORD   tc_TrapAlloc;	    /* traps allocated */
; 16.035   0      UWORD   tc_TrapAble;	    /* traps enabled */
; 16.036   0      APTR    tc_ExceptData;	    /* points to except data */
; 16.037   0      APTR    tc_ExceptCode;	    /* points to except code */
; 16.038   0      APTR    tc_TrapData;	    /* points to trap data */
; 16.039   0      APTR    tc_TrapCode;	    /* points to trap code */
; 16.040   0      APTR    tc_SPReg;		    /* stack pointer	    */
; 16.041   0      APTR    tc_SPLower;	    /* stack lower bound    */
; 16.042   0      APTR    tc_SPUpper;	    /* stack upper bound + 2*/
; 16.043   0      VOID    (*tc_Switch)();	    /* task losing CPU	  */
; 16.044   0      VOID    (*tc_Launch)();	    /* task getting CPU  */
; 16.045   0      struct  List tc_MemEntry;	    /* Allocated memory. Freed by RemTask() */
; 16.046   0      APTR    tc_UserData;	    /* For use by the task; no restrictions! */
; 16.047   0  };
; 16.048
; 16.049      /*
; 16.050       * Stack swap structure as passed to StackSwap()
; 16.051       */
; 16.052   0  struct	StackSwapStruct {
; 16.053   0  	APTR	stk_Lower;	/* Lowest byte of stack */
; 16.054   0  	ULONG	stk_Upper;	/* Upper end of stack (size + Lowest) */
; 16.055   0  	APTR	stk_Pointer;	/* Stack pointer at switch point */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 26
;
;
;Line#  Block                                  Source
; 16.056   0  };
; 16.057
; 16.058      /*----- Flag Bits ------------------------------------------*/
; 16.059   0  #define TB_PROCTIME	0
; 16.060   0  #define TB_ETASK	3
; 16.061   0  #define TB_STACKCHK	4
; 16.062   0  #define TB_EXCEPT	5
; 16.063   0  #define TB_SWITCH	6
; 16.064   0  #define TB_LAUNCH	7
; 16.065
; 16.066   0  #define TF_PROCTIME	(1L<<0)
; 16.067   0  #define TF_ETASK	(1L<<3)
; 16.068   0  #define TF_STACKCHK	(1L<<4)
; 16.069   0  #define TF_EXCEPT	(1L<<5)
; 16.070   0  #define TF_SWITCH	(1L<<6)
; 16.071   0  #define TF_LAUNCH	(1L<<7)
; 16.072
; 16.073      /*----- Task States ----------------------------------------*/
; 16.074   0  #define TS_INVALID	0
; 16.075   0  #define TS_ADDED	1
; 16.076   0  #define TS_RUN		2
; 16.077   0  #define TS_READY	3
; 16.078   0  #define TS_WAIT	4
; 16.079   0  #define TS_EXCEPT	5
; 16.080   0  #define TS_REMOVED	6
; 16.081
; 16.082      /*----- Predefined Signals -------------------------------------*/
; 16.083   0  #define SIGB_ABORT	0
; 16.084   0  #define SIGB_CHILD	1
; 16.085   0  #define SIGB_BLIT	4	/* Note: same as SINGLE */
; 16.086   0  #define SIGB_SINGLE	4	/* Note: same as BLIT */
; 16.087   0  #define SIGB_INTUITION	5
; 16.088   0  #define	SIGB_NET	7
; 16.089   0  #define SIGB_DOS	8
; 16.090
; 16.091   0  #define SIGF_ABORT	(1L<<0)
; 16.092   0  #define SIGF_CHILD	(1L<<1)
; 16.093   0  #define SIGF_BLIT	(1L<<4)
; 16.094   0  #define SIGF_SINGLE	(1L<<4)
; 16.095   0  #define SIGF_INTUITION	(1L<<5)
; 16.096   0  #define	SIGF_NET	(1L<<7)
; 16.097   0  #define SIGF_DOS	(1L<<8)
; 16.098
; 16.099   0  #endif	/* EXEC_TASKS_H */
; 15.019   0  #endif
; 15.020      /*------ misc ---------------------------------------------------------*/
; 15.021   0  ULONG Supervisor( unsigned long (*userFunction)() );
; 15.022      /*------ special patchable hooks to internal exec activity ------------*/
; 15.023      /*------ module creation ----------------------------------------------*/
; 15.024   0  void InitCode( unsigned long startClass, unsigned long version );

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 27
;
;
;Line#  Block                                  Source
; 15.025   0  void InitStruct( APTR initTable, APTR memory, unsigned long size );
; 15.026   0  struct Library *MakeLibrary( APTR funcInit, APTR structInit,
; 15.027   0  	unsigned long (*libInit)(), unsigned long dataSize,
; 15.028   0  	unsigned long segList );
; 15.029   0  void MakeFunctions( APTR target, APTR functionArray,
; 15.030   0  	unsigned long funcDispBase );
; 15.031   0  struct Resident *FindResident( UBYTE *name );
; 15.032   0  APTR InitResident( struct Resident *resident, unsigned long segList );
; 15.033      /*------ diagnostics --------------------------------------------------*/
; 15.034   0  void Alert( unsigned long alertNum );
; 15.035   0  void Debug( unsigned long flags );
; 15.036      /*------ interrupts ---------------------------------------------------*/
; 15.037   0  void Disable( void );
; 15.038   0  void Enable( void );
; 15.039   0  void Forbid( void );
; 15.040   0  void Permit( void );
; 15.041   0  ULONG SetSR( unsigned long newSR, unsigned long mask );
; 15.042   0  APTR SuperState( void );
; 15.043   0  void UserState( APTR sysStack );
; 15.044   0  struct Interrupt *SetIntVector( long intNumber, struct Interrupt *interrupt );
; 15.045   0  void AddIntServer( long intNumber, struct Interrupt *interrupt );
; 15.046   0  void RemIntServer( long intNumber, struct Interrupt *interrupt );
; 15.047   0  void Cause( struct Interrupt *interrupt );
; 15.048      /*------ memory allocation --------------------------------------------*/
; 15.049   0  APTR Allocate( struct MemHeader *freeList, unsigned long byteSize );
; 15.050   0  void Deallocate( struct MemHeader *freeList, APTR memoryBlock,
; 15.051   0  	unsigned long byteSize );
; 15.052   0  APTR AllocMem( unsigned long byteSize, unsigned long requirements );
; 15.053   0  APTR AllocAbs( unsigned long byteSize, APTR location );
; 15.054   0  void FreeMem( APTR memoryBlock, unsigned long byteSize );
; 15.055   0  ULONG AvailMem( unsigned long requirements );
; 15.056   0  struct MemList *AllocEntry( struct MemList *entry );
; 15.057   0  void FreeEntry( struct MemList *entry );
; 15.058      /*------ lists --------------------------------------------------------*/
; 15.059   0  void Insert( struct List *list, struct Node *node, struct Node *pred );
; 15.060   0  void AddHead( struct List *list, struct Node *node );
; 15.061   0  void AddTail( struct List *list, struct Node *node );
; 15.062   0  void Remove( struct Node *node );
; 15.063   0  struct Node *RemHead( struct List *list );
; 15.064   0  struct Node *RemTail( struct List *list );
; 15.065   0  void Enqueue( struct List *list, struct Node *node );
; 15.066   0  struct Node *FindName( struct List *list, UBYTE *name );
; 15.067      /*------ tasks --------------------------------------------------------*/
; 15.068   0  APTR AddTask( struct Task *task, APTR initPC, APTR finalPC );
; 15.069   0  void RemTask( struct Task *task );
; 15.070   0  struct Task *FindTask( UBYTE *name );
; 15.071   0  BYTE SetTaskPri( struct Task *task, long priority );
; 15.072   0  ULONG SetSignal( unsigned long newSignals, unsigned long signalSet );
; 15.073   0  ULONG SetExcept( unsigned long newSignals, unsigned long signalSet );
; 15.074   0  ULONG Wait( unsigned long signalSet );

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 28
;
;
;Line#  Block                                  Source
; 15.075   0  void Signal( struct Task *task, unsigned long signalSet );
; 15.076   0  BYTE AllocSignal( long signalNum );
; 15.077   0  void FreeSignal( long signalNum );
; 15.078   0  LONG AllocTrap( long trapNum );
; 15.079   0  void FreeTrap( long trapNum );
; 15.080      /*------ messages -----------------------------------------------------*/
; 15.081   0  void AddPort( struct MsgPort *port );
; 15.082   0  void RemPort( struct MsgPort *port );
; 15.083   0  void PutMsg( struct MsgPort *port, struct Message *message );
; 15.084   0  struct Message *GetMsg( struct MsgPort *port );
; 15.085   0  void ReplyMsg( struct Message *message );
; 15.086   0  struct Message *WaitPort( struct MsgPort *port );
; 15.087   0  struct MsgPort *FindPort( UBYTE *name );
; 15.088      /*------ libraries ----------------------------------------------------*/
; 15.089   0  void AddLibrary( struct Library *library );
; 15.090   0  void RemLibrary( struct Library *library );
; 15.091   0  struct Library *OldOpenLibrary( UBYTE *libName );
; 15.092   0  void CloseLibrary( struct Library *library );
; 15.093   0  APTR SetFunction( struct Library *library, long funcOffset,
; 15.094   0  	unsigned long (*newFunction)() );
; 15.095   0  void SumLibrary( struct Library *library );
; 15.096      /*------ devices ------------------------------------------------------*/
; 15.097   0  void AddDevice( struct Device *device );
; 15.098   0  void RemDevice( struct Device *device );
; 15.099   0  BYTE OpenDevice( UBYTE *devName, unsigned long unit,
; 15.100   0  	struct IORequest *ioRequest, unsigned long flags );
; 15.101   0  void CloseDevice( struct IORequest *ioRequest );
; 15.102   0  BYTE DoIO( struct IORequest *ioRequest );
; 15.103   0  void SendIO( struct IORequest *ioRequest );
; 15.104   0  struct IORequest *CheckIO( struct IORequest *ioRequest );
; 15.105   0  BYTE WaitIO( struct IORequest *ioRequest );
; 15.106   0  void AbortIO( struct IORequest *ioRequest );
; 15.107      /*------ resources ----------------------------------------------------*/
; 15.108   0  void AddResource( APTR resource );
; 15.109   0  void RemResource( APTR resource );
; 15.110   0  APTR OpenResource( UBYTE *resName );
; 15.111      /*------ private diagnostic support -----------------------------------*/
; 15.112      /*------ misc ---------------------------------------------------------*/
; 15.113   0  APTR RawDoFmt( UBYTE *formatString, APTR dataStream, void (*putChProc)(),
; 15.114   0  	APTR putChData );
; 15.115   0  ULONG GetCC( void );
; 15.116   0  ULONG TypeOfMem( APTR address );
; 15.117   0  ULONG Procure( struct SignalSemaphore *sigSem,
; 15.118   0  	struct SemaphoreMessage *bidMsg );
; 15.119   0  void Vacate( struct SignalSemaphore *sigSem,
; 15.120   0  	struct SemaphoreMessage *bidMsg );
; 15.121   0  struct Library *OpenLibrary( UBYTE *libName, unsigned long version );
; 15.122      /*--- functions in V33 or higher (Release 1.2) ---*/
; 15.123      /*------ signal semaphores (note funny registers)----------------------*/
; 15.124   0  void InitSemaphore( struct SignalSemaphore *sigSem );

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 29
;
;
;Line#  Block                                  Source
; 15.125   0  void ObtainSemaphore( struct SignalSemaphore *sigSem );
; 15.126   0  void ReleaseSemaphore( struct SignalSemaphore *sigSem );
; 15.127   0  ULONG AttemptSemaphore( struct SignalSemaphore *sigSem );
; 15.128   0  void ObtainSemaphoreList( struct List *sigSem );
; 15.129   0  void ReleaseSemaphoreList( struct List *sigSem );
; 15.130   0  struct SignalSemaphore *FindSemaphore( UBYTE *sigSem );
; 15.131   0  void AddSemaphore( struct SignalSemaphore *sigSem );
; 15.132   0  void RemSemaphore( struct SignalSemaphore *sigSem );
; 15.133      /*------ kickmem support ----------------------------------------------*/
; 15.134   0  ULONG SumKickData( void );
; 15.135      /*------ more memory support ------------------------------------------*/
; 15.136   0  void AddMemList( unsigned long size, unsigned long attributes, long pri,
; 15.137   0  	APTR base, UBYTE *name );
; 15.138   0  void CopyMem( APTR source, APTR dest, unsigned long size );
; 15.139   0  void CopyMemQuick( APTR source, APTR dest, unsigned long size );
; 15.140      /*------ cache --------------------------------------------------------*/
; 15.141      /*--- functions in V36 or higher (Release 2.0) ---*/
; 15.142   0  void CacheClearU( void );
; 15.143   0  void CacheClearE( APTR address, unsigned long length, unsigned long caches );
; 15.144   0  ULONG CacheControl( unsigned long cacheBits, unsigned long cacheMask );
; 15.145      /*------ misc ---------------------------------------------------------*/
; 15.146   0  APTR CreateIORequest( struct MsgPort *port, unsigned long size );
; 15.147   0  void DeleteIORequest( APTR iorequest );
; 15.148   0  struct MsgPort *CreateMsgPort( void );
; 15.149   0  void DeleteMsgPort( struct MsgPort *port );
; 15.150   0  void ObtainSemaphoreShared( struct SignalSemaphore *sigSem );
; 15.151      /*------ even more memory support -------------------------------------*/
; 15.152   0  APTR AllocVec( unsigned long byteSize, unsigned long requirements );
; 15.153   0  void FreeVec( APTR memoryBlock );
; 15.154      /*------ V39 Pool LVOs...*/
; 15.155   0  APTR CreatePool( unsigned long requirements, unsigned long puddleSize,
; 15.156   0  	unsigned long threshSize );
; 15.157   0  void DeletePool( APTR poolHeader );
; 15.158   0  APTR AllocPooled( APTR poolHeader, unsigned long memSize );
; 15.159   0  void FreePooled( APTR poolHeader, APTR memory, unsigned long memSize );
; 15.160      /*------ misc ---------------------------------------------------------*/
; 15.161   0  ULONG AttemptSemaphoreShared( struct SignalSemaphore *sigSem );
; 15.162   0  void ColdReboot( void );
; 15.163   0  void StackSwap( struct StackSwapStruct *newStack );
; 15.164      /*------ task trees ---------------------------------------------------*/
; 15.165   0  void ChildFree( APTR tid );
; 15.166   0  void ChildOrphan( APTR tid );
; 15.167   0  void ChildStatus( APTR tid );
; 15.168   0  void ChildWait( APTR tid );
; 15.169      /*------ future expansion ---------------------------------------------*/
; 15.170   0  APTR CachePreDMA( APTR address, ULONG *length, unsigned long flags );
; 15.171   0  void CachePostDMA( APTR address, ULONG *length, unsigned long flags );
; 15.172      /*------ New, for V39*/
; 15.173      /*--- functions in V39 or higher (Release 3) ---*/
; 15.174      /*------ Low memory handler functions*/

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 30
;
;
;Line#  Block                                  Source
; 15.175   0  void AddMemHandler( struct Interrupt *memhand );
; 15.176   0  void RemMemHandler( struct Interrupt *memhand );
; 15.177      /*------ Function to attempt to obtain a Quick Interrupt Vector...*/
; 15.178   0  ULONG ObtainQuickVector( APTR interruptCode );
; 15.179   0  #endif	 /* CLIB_EXEC_PROTOS_H */
; 14.006   0  #if defined(_USEOLDEXEC_) || !defined(__USE_SYSBASE)
; 14.007      #include <pragmas/exec_pragmas.h>
; 14.008      #else
; 14.009   0  extern struct ExecBase *SysBase;
; 14.010   0  #include <pragmas/exec_sysbase_pragmas.h>
;===> Including file "sc:include/pragmas/exec_sysbase_pragmas.h"
; 18.001      /*------ misc ---------------------------------------------------------*/
; 18.003      /*------ special patchable hooks to internal exec activity ------------*/
; 18.004      /*pragma libcall SysBase execPrivate1 24 0*/
; 18.005      /*pragma libcall SysBase execPrivate2 2a 0*/
; 18.006      /*pragma libcall SysBase execPrivate3 30 0*/
; 18.007      /*pragma libcall SysBase execPrivate4 36 0*/
; 18.008      /*pragma libcall SysBase execPrivate5 3c 0*/
; 18.009      /*pragma libcall SysBase execPrivate6 42 0*/
; 18.010      /*------ module creation ----------------------------------------------*/
; 18.017      /*------ diagnostics --------------------------------------------------*/
; 18.020      /*------ interrupts ---------------------------------------------------*/
; 18.032      /*------ memory allocation --------------------------------------------*/
; 18.041      /*------ lists --------------------------------------------------------*/
; 18.050      /*------ tasks --------------------------------------------------------*/
; 18.063      /*------ messages -----------------------------------------------------*/
; 18.071      /*------ libraries ----------------------------------------------------*/
; 18.078      /*------ devices ------------------------------------------------------*/
; 18.088      /*------ resources ----------------------------------------------------*/
; 18.092      /*------ private diagnostic support -----------------------------------*/
; 18.093      /*pragma libcall SysBase execPrivate7 1f8 0*/
; 18.094      /*pragma libcall SysBase execPrivate8 1fe 0*/
; 18.095      /*pragma libcall SysBase execPrivate9 204 0*/
; 18.096      /*------ misc ---------------------------------------------------------*/
; 18.103      /*--- functions in V33 or higher (Release 1.2) ---*/
; 18.104      /*------ signal semaphores (note funny registers)----------------------*/
; 18.114      /*------ kickmem support ----------------------------------------------*/
; 18.116      /*------ more memory support ------------------------------------------*/
; 18.120      /*------ cache --------------------------------------------------------*/
; 18.121      /*--- functions in V36 or higher (Release 2.0) ---*/
; 18.125      /*------ misc ---------------------------------------------------------*/
; 18.131      /*------ even more memory support -------------------------------------*/
; 18.134      /*------ V39 Pool LVOs...*/
; 18.139      /*------ misc ---------------------------------------------------------*/
; 18.143      /*------ task trees ---------------------------------------------------*/
; 18.148      /*------ future expansion ---------------------------------------------*/
; 18.151      /*------ New, for V39*/
; 18.152      /*--- functions in V39 or higher (Release 3) ---*/
; 18.153      /*------ Low memory handler functions*/
; 18.156      /*------ Function to attempt to obtain a Quick Interrupt Vector...*/

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 31
;
;
;Line#  Block                                  Source
; 18.158      /*pragma libcall SysBase execPrivate10 318 0*/
; 18.159      /*pragma libcall SysBase execPrivate11 31e 0*/
; 18.160      /*pragma libcall SysBase execPrivate12 324 0*/
; 18.161      /*pragma libcall SysBase execPrivate13 32a 0*/
; 18.162      /*pragma libcall SysBase execPrivate14 330 0*/
; 18.163      /*pragma libcall SysBase execPrivate15 336 0*/
; 14.011   0  #endif
; 14.012
; 14.013      /*------ Common support library functions ---------*/
; 14.014   0  #include <clib/alib_protos.h>
;===> Including file "sc:include/clib/alib_protos.h"
; 19.001   0  #ifndef  CLIB_ALIB_PROTOS_H
; 19.002   0  #define  CLIB_ALIB_PROTOS_H
; 19.003
; 19.004      /*
; 19.005      **	$VER: alib_protos.h 1.5 (25.8.92)
; 19.006      **	Includes Release 40.13
; 19.007      **
; 19.008      **	C prototypes. For use with 32 bit integers only.
; 19.009      **
; 19.010      **	(C) Copyright 1990-1993 Commodore-Amiga, Inc.
; 19.011      **	    All Rights Reserved
; 19.012      */
; 19.013
; 19.014   0  #ifndef  EXEC_TYPES_H
; 19.015      #include <exec/types.h>
; 19.016      #endif
; 19.017   0  #ifndef  DEVICES_TIMER_H
; 19.018   0  #include <devices/timer.h>
;===> Including file "sc:include/devices/timer.h"
; 20.001   0  #ifndef DEVICES_TIMER_H
; 20.002   0  #define DEVICES_TIMER_H 1
; 20.003      /*
; 20.004      **	$VER: timer.h 36.16 (25.1.91)
; 20.005      **	Includes Release 40.13
; 20.006      **
; 20.007      **	Timer device name and useful definitions.
; 20.008      **
; 20.009      **	(C) Copyright 1985-1993 Commodore-Amiga Inc.
; 20.010      **		All Rights Reserved
; 20.011      */
; 20.012
; 20.013   0  #include <exec/types.h>
; 20.014   0  #include <exec/io.h>
;===> Including file "sc:include/exec/io.h"
; 21.001   0  #ifndef	EXEC_IO_H
; 21.002   0  #define	EXEC_IO_H
; 21.003      /*
; 21.004      **	$VER: io.h 39.0 (15.10.91)
; 21.005      **	Includes Release 40.13

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 32
;
;
;Line#  Block                                  Source
; 21.006      **
; 21.007      **	Message structures used for device communication
; 21.008      **
; 21.009      **	(C) Copyright 1985-1993 Commodore-Amiga, Inc.
; 21.010      **	    All Rights Reserved
; 21.011      */
; 21.012
; 21.013   0  #ifndef EXEC_PORTS_H
; 21.014   0  #include "exec/ports.h"
;===> Including file "sc:include/exec/ports.h"
; 22.001   0  #ifndef	EXEC_PORTS_H
; 22.002   0  #define	EXEC_PORTS_H
; 22.003      /*
; 22.004      **	$VER: ports.h 39.0 (15.10.91)
; 22.005      **	Includes Release 40.13
; 22.006      **
; 22.007      **	Message ports and Messages.
; 22.008      **
; 22.009      **	(C) Copyright 1985-1993 Commodore-Amiga, Inc.
; 22.010      **	    All Rights Reserved
; 22.011      */
; 22.012
; 22.013   0  #ifndef EXEC_NODES_H
; 22.014      #include "exec/nodes.h"
; 22.015      #endif /* EXEC_NODES_H */
; 22.016
; 22.017   0  #ifndef EXEC_LISTS_H
; 22.018      #include "exec/lists.h"
; 22.019      #endif /* EXEC_LISTS_H */
; 22.020
; 22.021   0  #ifndef EXEC_TASKS_H
; 22.022      #include "exec/tasks.h"
; 22.023      #endif /* EXEC_TASKS_H */
; 22.024
; 22.025
; 22.026      /****** MsgPort *****************************************************/
; 22.027
; 22.028   0  struct MsgPort {
; 22.029   0      struct  Node mp_Node;
; 22.030   0      UBYTE   mp_Flags;
; 22.031   0      UBYTE   mp_SigBit;		/* signal bit number	*/
; 22.032   0      void   *mp_SigTask;		/* object to be signalled */
; 22.033   0      struct  List mp_MsgList;	/* message linked list	*/
; 22.034   0  };
; 22.035
; 22.036   0  #define mp_SoftInt mp_SigTask	/* Alias */
; 22.037
; 22.038      /* mp_Flags: Port arrival actions (PutMsg) */
; 22.039   0  #define PF_ACTION	3	/* Mask */
; 22.040   0  #define PA_SIGNAL	0	/* Signal task in mp_SigTask */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 33
;
;
;Line#  Block                                  Source
; 22.041   0  #define PA_SOFTINT	1	/* Signal SoftInt in mp_SoftInt/mp_SigTask */
; 22.042   0  #define PA_IGNORE	2	/* Ignore arrival */
; 22.043
; 22.044
; 22.045      /****** Message *****************************************************/
; 22.046
; 22.047   0  struct Message {
; 22.048   0      struct  Node mn_Node;
; 22.049   0      struct  MsgPort *mn_ReplyPort;  /* message reply port */
; 22.050   0      UWORD   mn_Length;		    /* total message length, in bytes */
; 22.051      				    /* (include the size of the Message */
; 22.052      				    /* structure in the length) */
; 22.053   0  };
; 22.054
; 22.055   0  #endif	/* EXEC_PORTS_H */
; 21.015   0  #endif /* EXEC_PORTS_H */
; 21.016
; 21.017
; 21.018   0  struct IORequest {
; 21.019   0      struct  Message io_Message;
; 21.020   0      struct  Device  *io_Device;     /* device node pointer  */
; 21.021   0      struct  Unit    *io_Unit;	    /* unit (driver private)*/
; 21.022   0      UWORD   io_Command;	    /* device command */
; 21.023   0      UBYTE   io_Flags;
; 21.024   0      BYTE    io_Error;		    /* error or warning num */
; 21.025   0  };
; 21.026
; 21.027   0  struct IOStdReq {
; 21.028   0      struct  Message io_Message;
; 21.029   0      struct  Device  *io_Device;     /* device node pointer  */
; 21.030   0      struct  Unit    *io_Unit;	    /* unit (driver private)*/
; 21.031   0      UWORD   io_Command;	    /* device command */
; 21.032   0      UBYTE   io_Flags;
; 21.033   0      BYTE    io_Error;		    /* error or warning num */
; 21.034   0      ULONG   io_Actual;		    /* actual number of bytes transferred */
; 21.035   0      ULONG   io_Length;		    /* requested number bytes transferred*/
; 21.036   0      APTR    io_Data;		    /* points to data area */
; 21.037   0      ULONG   io_Offset;		    /* offset for block structured devices */
; 21.038   0  };
; 21.039
; 21.040      /* library vector offsets for device reserved vectors */
; 21.041   0  #define DEV_BEGINIO	(-30)
; 21.042   0  #define DEV_ABORTIO	(-36)
; 21.043
; 21.044      /* io_Flags defined bits */
; 21.045   0  #define IOB_QUICK	0
; 21.046   0  #define IOF_QUICK	(1<<0)
; 21.047
; 21.048
; 21.049   0  #define CMD_INVALID	0

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 34
;
;
;Line#  Block                                  Source
; 21.050   0  #define CMD_RESET	1
; 21.051   0  #define CMD_READ	2
; 21.052   0  #define CMD_WRITE	3
; 21.053   0  #define CMD_UPDATE	4
; 21.054   0  #define CMD_CLEAR	5
; 21.055   0  #define CMD_STOP	6
; 21.056   0  #define CMD_START	7
; 21.057   0  #define CMD_FLUSH	8
; 21.058
; 21.059   0  #define CMD_NONSTD	9
; 21.060
; 21.061   0  #endif	/* EXEC_IO_H */
; 20.015
; 20.016      /* unit defintions */
; 20.017   0  #define UNIT_MICROHZ	0
; 20.018   0  #define UNIT_VBLANK	1
; 20.019   0  #define UNIT_ECLOCK	2
; 20.020   0  #define UNIT_WAITUNTIL	3
; 20.021   0  #define	UNIT_WAITECLOCK	4
; 20.022
; 20.023   0  #define TIMERNAME	"timer.device"
; 20.024
; 20.025   0  struct timeval {
; 20.026   0      ULONG tv_secs;
; 20.027   0      ULONG tv_micro;
; 20.028   0  };
; 20.029
; 20.030   0  struct EClockVal {
; 20.031   0      ULONG ev_hi;
; 20.032   0      ULONG ev_lo;
; 20.033   0  };
; 20.034
; 20.035   0  struct timerequest {
; 20.036   0      struct IORequest tr_node;
; 20.037   0      struct timeval tr_time;
; 20.038   0  };
; 20.039
; 20.040      /* IO_COMMAND to use for adding a timer */
; 20.041   0  #define TR_ADDREQUEST	CMD_NONSTD
; 20.042   0  #define TR_GETSYSTIME	(CMD_NONSTD+1)
; 20.043   0  #define TR_SETSYSTIME	(CMD_NONSTD+2)
; 20.044
; 20.045   0  #endif /* DEVICES_TIMER_H */
; 19.019   0  #endif
; 19.020   0  #ifndef  DEVICES_KEYMAP_H
; 19.021   0  #include <devices/keymap.h>
;===> Including file "sc:include/devices/keymap.h"
; 23.001   0  #ifndef	DEVICES_KEYMAP_H
; 23.002   0  #define	DEVICES_KEYMAP_H
; 23.003      /*

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 35
;
;
;Line#  Block                                  Source
; 23.004      **	$VER: keymap.h 36.3 (13.4.90)
; 23.005      **	Includes Release 40.13
; 23.006      **
; 23.007      **	key map definitions for keymap.resource, keymap.library, and
; 23.008      **	console.device
; 23.009      **
; 23.010      **	(C) Copyright 1985-1993 Commodore-Amiga, Inc.
; 23.011      **	    All Rights Reserved
; 23.012      */
; 23.013
; 23.014   0  #ifndef EXEC_NODES_H
; 23.015      #include	"exec/nodes.h"
; 23.016      #endif
; 23.017   0  #ifndef EXEC_LISTS_H
; 23.018      #include	"exec/lists.h"
; 23.019      #endif
; 23.020
; 23.021   0  struct	 KeyMap {
; 23.022   0      UBYTE   *km_LoKeyMapTypes;
; 23.023   0      ULONG   *km_LoKeyMap;
; 23.024   0      UBYTE   *km_LoCapsable;
; 23.025   0      UBYTE   *km_LoRepeatable;
; 23.026   0      UBYTE   *km_HiKeyMapTypes;
; 23.027   0      ULONG   *km_HiKeyMap;
; 23.028   0      UBYTE   *km_HiCapsable;
; 23.029   0      UBYTE   *km_HiRepeatable;
; 23.030   0  };
; 23.031
; 23.032   0  struct	KeyMapNode {
; 23.033   0      struct Node kn_Node;	/* including name of keymap */
; 23.034   0      struct KeyMap kn_KeyMap;
; 23.035   0  };
; 23.036
; 23.037      /* the structure of keymap.resource */
; 23.038   0  struct	KeyMapResource {
; 23.039   0      struct Node kr_Node;
; 23.040   0      struct List kr_List;	/* a list of KeyMapNodes */
; 23.041   0  };
; 23.042
; 23.043      /* Key Map Types */
; 23.044   0  #define  KC_NOQUAL   0
; 23.045   0  #define  KC_VANILLA  7		/* note that SHIFT+ALT+CTRL is VANILLA */
; 23.046   0  #define  KCB_SHIFT   0
; 23.047   0  #define  KCF_SHIFT   0x01
; 23.048   0  #define  KCB_ALT     1
; 23.049   0  #define  KCF_ALT     0x02
; 23.050   0  #define  KCB_CONTROL 2
; 23.051   0  #define  KCF_CONTROL 0x04
; 23.052   0  #define  KCB_DOWNUP  3
; 23.053   0  #define  KCF_DOWNUP  0x08

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 36
;
;
;Line#  Block                                  Source
; 23.054
; 23.055   0  #define  KCB_DEAD    5		/* may be dead or modified by dead key: */
; 23.056   0  #define  KCF_DEAD    0x20	/*   use dead prefix bytes		*/
; 23.057
; 23.058   0  #define  KCB_STRING  6
; 23.059   0  #define  KCF_STRING  0x40
; 23.060
; 23.061   0  #define  KCB_NOP     7
; 23.062   0  #define  KCF_NOP     0x80
; 23.063
; 23.064
; 23.065      /* Dead Prefix Bytes */
; 23.066   0  #define DPB_MOD	0
; 23.067   0  #define DPF_MOD	0x01
; 23.068   0  #define DPB_DEAD	3
; 23.069   0  #define DPF_DEAD	0x08
; 23.070
; 23.071   0  #define DP_2DINDEXMASK	0x0f	/* mask for index for 1st of two dead keys */
; 23.072   0  #define DP_2DFACSHIFT	4	/* shift for factor for 1st of two dead keys */
; 23.073
; 23.074   0  #endif	/* DEVICES_KEYMAP_H */
; 19.022   0  #endif
; 19.023   0  #ifndef  LIBRARIES_COMMODITIES_H
; 19.024   0  #include <libraries/commodities.h>
;===> Including file "sc:include/libraries/commodities.h"
; 24.001   0  #ifndef LIBRARIES_COMMODITIES_H
; 24.002   0  #define LIBRARIES_COMMODITIES_H
; 24.003      /*
; 24.004      **	$VER: commodities.h 38.4 (24.2.93)
; 24.005      **	Includes Release 40.13
; 24.006      **
; 24.007      **	Commodities definitions
; 24.008      **
; 24.009      **	(C) Copyright 1990-1993 Commodore-Amiga Inc.
; 24.010      **	All Rights Reserved
; 24.011      */
; 24.012
; 24.013      /*****************************************************************************/
; 24.014
; 24.015
; 24.016   0  #ifndef EXEC_TYPES_H
; 24.017      #include <exec/types.h>
; 24.018      #endif
; 24.019
; 24.020   0  #ifndef EXEC_PORTS_H
; 24.021      #include <exec/ports.h>
; 24.022      #endif
; 24.023
; 24.024
; 24.025      /*****************************************************************************/

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 37
;
;
;Line#  Block                                  Source
; 24.026
; 24.027
; 24.028      /* object creation macros */
; 24.029   0  #define CxFilter(d)	    CreateCxObj((LONG) CX_FILTER,     (LONG) d,     0)
; 24.030   0  #define CxSender(port,id)   CreateCxObj((LONG) CX_SEND,       (LONG) port,  (LON
;       ..... G) id)
; 24.031   0  #define CxSignal(task,sig)  CreateCxObj((LONG) CX_SIGNAL,     (LONG) task,  (LON
;       ..... G) sig)
; 24.032   0  #define CxTranslate(ie)     CreateCxObj((LONG) CX_TRANSLATE,  (LONG) ie,    0)
; 24.033   0  #define CxDebug(id)	    CreateCxObj((LONG) CX_DEBUG,      (LONG) id,    0)
; 24.034   0  #define CxCustom(action,id) CreateCxObj((LONG) CX_CUSTOM,     (LONG)action, (LON
;       ..... G)id)
; 24.035
; 24.036
; 24.037      /*****************************************************************************/
; 24.038
; 24.039
; 24.040   0  struct NewBroker
; 24.041   0  {
; 24.042   0      BYTE	    nb_Version;   /* Must be set to NB_VERSION */
; 24.043   0      STRPTR	    nb_Name;
; 24.044   0      STRPTR	    nb_Title;
; 24.045   0      STRPTR	    nb_Descr;
; 24.046   0      WORD	    nb_Unique;
; 24.047   0      WORD	    nb_Flags;
; 24.048   0      BYTE	    nb_Pri;
; 24.049   0      struct MsgPort *nb_Port;
; 24.050   0      WORD	    nb_ReservedChannel;
; 24.051   0  };
; 24.052
; 24.053      /* constant for NewBroker.nb_Version */
; 24.054   0  #define NB_VERSION 5	    /* Version of NewBroker structure */
; 24.055
; 24.056      /* Sizes for various buffers */
; 24.057   0  #define CBD_NAMELEN  24
; 24.058   0  #define CBD_TITLELEN 40
; 24.059   0  #define CBD_DESCRLEN 40
; 24.060
; 24.061      /* Flags for NewBroker.nb_Unique */
; 24.062   0  #define NBU_DUPLICATE 0
; 24.063   0  #define NBU_UNIQUE    1        /* will not allow duplicates	      */
; 24.064   0  #define NBU_NOTIFY    2        /* sends CXM_UNIQUE to existing broker */
; 24.065
; 24.066      /* Flags for NewBroker.nb_Flags */
; 24.067   0  #define COF_SHOW_HIDE 4
; 24.068
; 24.069
; 24.070      /*****************************************************************************/
; 24.071
; 24.072

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 38
;
;
;Line#  Block                                  Source
; 24.073      /* Fake data types for system private objects */
; 24.074   0  #ifndef COMMODITIES_BASE_H
; 24.075   0  typedef LONG CxObj;
; 24.076   0  typedef LONG CxMsg;
; 24.077   0  #endif
; 24.078
; 24.079      /* Pointer to a function returning a LONG */
; 24.080   0  typedef LONG (*PFL)();
; 24.081
; 24.082
; 24.083      /*****************************************************************************/
; 24.084
; 24.085
; 24.086      /* Commodities object types */
; 24.087   0  #define CX_INVALID	0     /* not a valid object (probably null) */
; 24.088   0  #define CX_FILTER	1     /* input event messages only	    */
; 24.089   0  #define CX_TYPEFILTER	2     /* obsolete, do not use		    */
; 24.090   0  #define CX_SEND	3     /* sends a message		    */
; 24.091   0  #define CX_SIGNAL	4     /* sends a signal		    */
; 24.092   0  #define CX_TRANSLATE	5     /* translates input event into chain  */
; 24.093   0  #define CX_BROKER	6     /* application representative	    */
; 24.094   0  #define CX_DEBUG	7     /* dumps info to serial port	    */
; 24.095   0  #define CX_CUSTOM	8     /* application provides function	    */
; 24.096   0  #define CX_ZERO	9     /* system terminator node	    */
; 24.097
; 24.098
; 24.099      /*****************************************************************************/
; 24.100
; 24.101
; 24.102      /* Commodities message types */
; 24.103   0  #define CXM_IEVENT  (1 << 5)
; 24.104   0  #define CXM_COMMAND (1 << 6)
; 24.105
; 24.106      /* Only CXM_IEVENT messages are passed through the input network. Other types
; 24.107       * of messages are sent to an optional port in your broker. This means that
; 24.108       * you must test the message type in your message handling, if input messages
; 24.109       * and command messages come to the same port.
; 24.110       *
; 24.111       * CXM_IEVENT: Messages of this type rattle around the Commodities input
; 24.112       *	       network. They are sent to you by a Sender object, and passed
; 24.113       *	       to you as a synchronous function call by a Custom object.
; 24.114       *
; 24.115       *	       The message port or function entry point is stored in the
; 24.116       *	       object, and the ID field of the message will be set to what
; 24.117       *	       you arrange issuing object.
; 24.118       *
; 24.119       *	       The data section of the message will point to the input event
; 24.120       *	       triggering the message.
; 24.121       *
; 24.122       * CXM_COMMAND: These messages are sent to a port attached to your Broker.

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 39
;
;
;Line#  Block                                  Source
; 24.123       *		They are sent to you when the controller program wants your
; 24.124       *		program to do something. The ID value identifies the command.
; 24.125       */
; 24.126
; 24.127      /* ID values associated with a message of type CXM_COMMAND */
; 24.128   0  #define CXCMD_DISABLE	(15)  /* please disable yourself	 */
; 24.129   0  #define CXCMD_ENABLE	(17)  /* please enable yourself	 */
; 24.130   0  #define CXCMD_APPEAR	(19)  /* open your window, if you can	 */
; 24.131   0  #define CXCMD_DISAPPEAR (21)  /* go dormant			 */
; 24.132   0  #define CXCMD_KILL	(23)  /* go away for good		 */
; 24.133   0  #define CXCMD_LIST_CHG	(27)  /* Someone changed the broker list */
; 24.134   0  #define CXCMD_UNIQUE	(25)  /* someone tried to create a broker
; 24.135   0  			       * with your name. Suggest you appear.
; 24.136   0  			       */
; 24.137
; 24.138
; 24.139      /*****************************************************************************/
; 24.140
; 24.141
; 24.142   0  struct InputXpression
; 24.143   0  {
; 24.144   0      UBYTE ix_Version;	  /* must be set to IX_VERSION */
; 24.145   0      UBYTE ix_Class;	  /* class must match exactly  */
; 24.146
; 24.147   0      UWORD ix_Code;	  /* Bits that we want */
; 24.148   0      UWORD ix_CodeMask;	  /* Set bits here to indicate which bits in ix_Code
; 24.149   0  			   * are don't care bits.
; 24.150   0  			   */
; 24.151   0      UWORD ix_Qualifier;   /* Bits that we want */
; 24.152   0      UWORD ix_QualMask;	  /* Set bits here to indicate which bits in
; 24.153   0  			   * ix_Qualifier are don't care bits
; 24.154   0  			   */
; 24.155   0      UWORD ix_QualSame;	  /* synonyms in qualifier */
; 24.156   0  };
; 24.157   0  typedef struct InputXpression IX;
; 24.158
; 24.159      /* constant for InputXpression.ix_Version */
; 24.160   0  #define IX_VERSION 2
; 24.161
; 24.162      /* constants for InputXpression.ix_QualSame */
; 24.163   0  #define IXSYM_SHIFT 1	/* left- and right- shift are equivalent     */
; 24.164   0  #define IXSYM_CAPS  2	/* either shift or caps lock are equivalent  */
; 24.165   0  #define IXSYM_ALT   4	/* left- and right- alt are equivalent	     */
; 24.166
; 24.167   0  #define IXSYM_SHIFTMASK (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT)
; 24.168   0  #define IXSYM_CAPSMASK	(IXSYM_SHIFTMASK | IEQUALIFIER_CAPSLOCK)
; 24.169   0  #define IXSYM_ALTMASK	(IEQUALIFIER_LALT | IEQUALIFIER_RALT)
; 24.170
; 24.171      /* constant for InputXpression.ix_QualMask */
; 24.172   0  #define IX_NORMALQUALS	0x7FFF	 /* avoid RELATIVEMOUSE */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 40
;
;
;Line#  Block                                  Source
; 24.173
; 24.174      /* matches nothing */
; 24.175   0  #define NULL_IX(ix)   ((ix)->ix_Class == IECLASS_NULL)
; 24.176
; 24.177
; 24.178      /*****************************************************************************/
; 24.179
; 24.180
; 24.181      /* Error returns from CxBroker() */
; 24.182   0  #define CBERR_OK      0  /* No error				   */
; 24.183   0  #define CBERR_SYSERR  1  /* System error, no memory, etc	   */
; 24.184   0  #define CBERR_DUP     2  /* uniqueness violation		   */
; 24.185   0  #define CBERR_VERSION 3  /* didn't understand NewBroker.nb_Version */
; 24.186
; 24.187
; 24.188      /*****************************************************************************/
; 24.189
; 24.190
; 24.191      /* Return values from CxObjError() */
; 24.192   0  #define COERR_ISNULL	 1   /* you called CxObjError(NULL)	   */
; 24.193   0  #define COERR_NULLATTACH 2   /* someone attached NULL to my list   */
; 24.194   0  #define COERR_BADFILTER  4   /* a bad filter description was given */
; 24.195   0  #define COERR_BADTYPE	 8   /* unmatched type-specific operation  */
; 24.196
; 24.197
; 24.198      /*****************************************************************************/
; 24.199
; 24.200
; 24.201   0  #endif /* LIBRARIES_COMMODITIES_H */
; 19.025   0  #endif
; 19.026   0  #ifndef  UTILITY_HOOKS_H
; 19.027   0  #include <utility/hooks.h>
;===> Including file "sc:include/utility/hooks.h"
; 25.001   0  #ifndef UTILITY_HOOKS_H
; 25.002   0  #define UTILITY_HOOKS_H
; 25.003      /*
; 25.004      **	$VER: hooks.h 39.2 (16.6.93)
; 25.005      **	Includes Release 40.13
; 25.006      **
; 25.007      **	Callback hooks
; 25.008      **
; 25.009      **	(C) Copyright 1989-1993 Commodore-Amiga Inc.
; 25.010      **	All Rights Reserved
; 25.011      */
; 25.012
; 25.013      /*****************************************************************************/
; 25.014
; 25.015
; 25.016   0  #ifndef EXEC_TYPES_H
; 25.017      #include <exec/types.h>

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 41
;
;
;Line#  Block                                  Source
; 25.018      #endif
; 25.019
; 25.020   0  #ifndef EXEC_NODES_H
; 25.021      #include <exec/nodes.h>
; 25.022      #endif
; 25.023
; 25.024
; 25.025      /*****************************************************************************/
; 25.026
; 25.027
; 25.028   0  struct Hook
; 25.029   0  {
; 25.030   0      struct MinNode h_MinNode;
; 25.031   0      ULONG	   (*h_Entry)();	/* assembler entry point */
; 25.032   0      ULONG	   (*h_SubEntry)();	/* often HLL entry point */
; 25.033   0      APTR	   h_Data;		/* owner specific	 */
; 25.034   0  };
; 25.035
; 25.036      /* Useful definition for casting function pointers:
; 25.037       * hook.h_SubEntry = (HOOKFUNC)AFunction
; 25.038       */
; 25.039   0  typedef unsigned long (*HOOKFUNC)();
; 25.040
; 25.041      /* Hook calling conventions.
; 25.042       *
; 25.043       * The function pointed to by Hook.h_Entry is called with the following
; 25.044       * parameters:
; 25.045       *
; 25.046       *	A0 - pointer to hook data structure itself
; 25.047       *	A1 - pointer to parameter structure ("message")
; 25.048       *	A2 - Hook specific address data ("object")
; 25.049       *
; 25.050       * Control will be passed to the routine h_Entry.  For many
; 25.051       * High-Level Languages (HLL), this will be an assembly language
; 25.052       * stub which pushes registers on the stack, does other setup,
; 25.053       * and then calls the function at h_SubEntry.
; 25.054       *
; 25.055       * The standard C receiving code is:
; 25.056       *
; 25.057       *    HookFunc(struct Hook *hook, APTR object, APTR message)
; 25.058       *
; 25.059       * Note that register natural order differs from this convention for C
; 25.060       * parameter order, which is A0,A2,A1.
; 25.061       *
; 25.062       * The assembly language stub for "vanilla" C parameter conventions
; 25.063       * could be:
; 25.064       *
; 25.065       * _hookEntry:
; 25.066       *	move.l	a1,-(sp)		; push message packet pointer
; 25.067       *	move.l	a2,-(sp)		; push object pointer

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 42
;
;
;Line#  Block                                  Source
; 25.068       *	move.l	a0,-(sp)		; push hook pointer
; 25.069       *	move.l	h_SubEntry(a0),a0	; fetch C entry point ...
; 25.070       *	jsr	(a0)			; ... and call it
; 25.071       *	lea	12(sp),sp		; fix stack
; 25.072       *	rts
; 25.073       *
; 25.074       * With this function as your interface stub, you can write a Hook setup
; 25.075       * function as:
; 25.076       *
; 25.077       * InitHook(struct Hook *hook, ULONG (*c_function)(), APTR userdata)
; 25.078       * {
; 25.079       * ULONG (*hookEntry)();
; 25.080       *
; 25.081       *     hook->h_Entry	= hookEntry;
; 25.082       *     hook->h_SubEntry = c_function;
; 25.083       *     hook->h_Data	= userdata;
; 25.084       * }
; 25.085       *
; 25.086       * With a compiler capable of registerized parameters, such as SAS C, you
; 25.087       * can put the C function in the h_Entry field directly. For example, for
; 25.088       * SAS C:
; 25.089       *
; 25.090       *   ULONG __saveds __asm HookFunc(register __a0 struct Hook *hook,
; 25.091       *				   register __a2 APTR	      object,
; 25.092       *				   register __a1 APTR	      message);
; 25.093       *
; 25.094       */
; 25.095
; 25.096
; 25.097      /*****************************************************************************/
; 25.098
; 25.099
; 25.100   0  #endif /* UTILITY_HOOKS_H */
; 19.028   0  #endif
; 19.029   0  #ifndef  INTUITION_CLASSES_H
; 19.030   0  #include <intuition/classes.h>
;===> Including file "sc:include/intuition/classes.h"
; 26.001   0  #ifndef	INTUITION_CLASSES_H
; 26.002   0  #define INTUITION_CLASSES_H	1
; 26.003      /*
; 26.004      **  $VER: classes.h 38.1 (11.11.91)
; 26.005      **  Includes Release 40.13
; 26.006      **
; 26.007      **  Used only by class implementors
; 26.008      **
; 26.009      **  (C) Copyright 1989-1993 Commodore-Amiga, Inc.
; 26.010      **	    All Rights Reserved
; 26.011      */
; 26.012
; 26.013   0  #ifndef UTILITY_HOOKS_H

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 43
;
;
;Line#  Block                                  Source
; 26.014      #include <utility/hooks.h>
; 26.015      #endif
; 26.016
; 26.017   0  #ifndef	INTUITION_CLASSUSR_H
; 26.018   0  #include <intuition/classusr.h>
;===> Including file "sc:include/intuition/classusr.h"
; 27.001   0  #ifndef	INTUITION_CLASSUSR_H
; 27.002   0  #define INTUITION_CLASSUSR_H	1
; 27.003      /*
; 27.004      **  $VER: classusr.h 38.2 (14.4.92)
; 27.005      **  Includes Release 40.13
; 27.006      **
; 27.007      **  For application users of Intuition object classes
; 27.008      **
; 27.009      **  (C) Copyright 1989-1993 Commodore-Amiga, Inc.
; 27.010      **	    All Rights Reserved
; 27.011      */
; 27.012
; 27.013
; 27.014   0  #ifndef UTILITY_HOOKS_H
; 27.015      #include <utility/hooks.h>
; 27.016      #endif
; 27.017
; 27.018      /*** User visible handles on objects, classes, messages ***/
; 27.019   0  typedef ULONG	Object;		/* abstract handle */
; 27.020
; 27.021   0  typedef	UBYTE	*ClassID;
; 27.022
; 27.023      /* you can use this type to point to a "generic" message,
; 27.024       * in the object-oriented programming parlance.  Based on
; 27.025       * the value of 'MethodID', you dispatch to processing
; 27.026       * for the various message types.  The meaningful parameter
; 27.027       * packet structure definitions are defined below.
; 27.028       */
; 27.029   0  typedef struct {
; 27.030   0      ULONG MethodID;
; 27.031          /* method-specific data follows, some examples below */
; 27.032   0  }		*Msg;
; 27.033
; 27.034      /*
; 27.035       * Class id strings for Intuition classes.
; 27.036       * There's no real reason to use the uppercase constants
; 27.037       * over the lowercase strings, but this makes a good place
; 27.038       * to list the names of the built-in classes.
; 27.039       */
; 27.040   0  #define ROOTCLASS	"rootclass"		/* classusr.h	  */
; 27.041   0  #define IMAGECLASS	"imageclass"		/* imageclass.h   */
; 27.042   0  #define FRAMEICLASS	"frameiclass"
; 27.043   0  #define SYSICLASS	"sysiclass"
; 27.044   0  #define FILLRECTCLASS	"fillrectclass"

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 44
;
;
;Line#  Block                                  Source
; 27.045   0  #define GADGETCLASS	"gadgetclass"		/* gadgetclass.h  */
; 27.046   0  #define PROPGCLASS	"propgclass"
; 27.047   0  #define STRGCLASS	"strgclass"
; 27.048   0  #define BUTTONGCLASS	"buttongclass"
; 27.049   0  #define FRBUTTONCLASS	"frbuttonclass"
; 27.050   0  #define GROUPGCLASS	"groupgclass"
; 27.051   0  #define ICCLASS		"icclass"		/* icclass.h	  */
; 27.052   0  #define MODELCLASS	"modelclass"
; 27.053   0  #define ITEXTICLASS	"itexticlass"
; 27.054   0  #define POINTERCLASS	"pointerclass"		/* pointerclass.h */
; 27.055
; 27.056      /* Dispatched method ID's
; 27.057       * NOTE: Applications should use Intuition entry points, not direct
; 27.058       * DoMethod() calls, for NewObject, DisposeObject, SetAttrs,
; 27.059       * SetGadgetAttrs, and GetAttr.
; 27.060       */
; 27.061
; 27.062   0  #define OM_Dummy	(0x100)
; 27.063   0  #define OM_NEW		(0x101)	/* 'object' parameter is "true class"	*/
; 27.064   0  #define OM_DISPOSE	(0x102)	/* delete self (no parameters)		*/
; 27.065   0  #define OM_SET		(0x103)	/* set attributes (in tag list)		*/
; 27.066   0  #define OM_GET		(0x104)	/* return single attribute value	*/
; 27.067   0  #define OM_ADDTAIL	(0x105)	/* add self to a List (let root do it)	*/
; 27.068   0  #define OM_REMOVE	(0x106)	/* remove self from list		*/
; 27.069   0  #define OM_NOTIFY	(0x107)	/* send to self: notify dependents	*/
; 27.070   0  #define OM_UPDATE	(0x108)	/* notification message from somebody	*/
; 27.071   0  #define OM_ADDMEMBER	(0x109)	/* used by various classes with lists	*/
; 27.072   0  #define OM_REMMEMBER	(0x10A)	/* used by various classes with lists	*/
; 27.073
; 27.074      /* Parameter "Messages" passed to methods	*/
; 27.075
; 27.076      /* OM_NEW and OM_SET	*/
; 27.077   0  struct opSet {
; 27.078   0      ULONG		MethodID;
; 27.079   0      struct TagItem	*ops_AttrList;	/* new attributes	*/
; 27.080   0      struct GadgetInfo	*ops_GInfo;	/* always there for gadgets,
; 27.081   0  					 * when SetGadgetAttrs() is used,
; 27.082   0  					 * but will be NULL for OM_NEW
; 27.083   0  					 */
; 27.084   0  };
; 27.085
; 27.086      /* OM_NOTIFY, and OM_UPDATE	*/
; 27.087   0  struct opUpdate {
; 27.088   0      ULONG		MethodID;
; 27.089   0      struct TagItem	*opu_AttrList;	/* new attributes	*/
; 27.090   0      struct GadgetInfo	*opu_GInfo;	/* non-NULL when SetGadgetAttrs or
; 27.091   0  					 * notification resulting from gadget
; 27.092   0  					 * input occurs.
; 27.093   0  					 */
; 27.094   0      ULONG		opu_Flags;	/* defined below	*/

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 45
;
;
;Line#  Block                                  Source
; 27.095   0  };
; 27.096
; 27.097      /* this flag means that the update message is being issued from
; 27.098       * something like an active gadget, a la GACT_FOLLOWMOUSE.  When
; 27.099       * the gadget goes inactive, it will issue a final update
; 27.100       * message with this bit cleared.  Examples of use are for
; 27.101       * GACT_FOLLOWMOUSE equivalents for propgadclass, and repeat strobes
; 27.102       * for buttons.
; 27.103       */
; 27.104   0  #define OPUF_INTERIM	(1<<0)
; 27.105
; 27.106      /* OM_GET	*/
; 27.107   0  struct opGet {
; 27.108   0      ULONG		MethodID;
; 27.109   0      ULONG		opg_AttrID;
; 27.110   0      ULONG		*opg_Storage;	/* may be other types, but "int"
; 27.111   0  					 * types are all ULONG
; 27.112   0  					 */
; 27.113   0  };
; 27.114
; 27.115      /* OM_ADDTAIL	*/
; 27.116   0  struct opAddTail {
; 27.117   0      ULONG		MethodID;
; 27.118   0      struct List		*opat_List;
; 27.119   0  };
; 27.120
; 27.121      /* OM_ADDMEMBER, OM_REMMEMBER	*/
; 27.122   0  #define  opAddMember opMember
; 27.123   0  struct opMember {
; 27.124   0      ULONG		MethodID;
; 27.125   0      Object		*opam_Object;
; 27.126   0  };
; 27.127
; 27.128
; 27.129   0  #endif
; 26.019   0  #endif
; 26.020
; 26.021      /*******************************************/
; 26.022      /*** "White box" access to struct IClass ***/
; 26.023      /*******************************************/
; 26.024
; 26.025      /* This structure is READ-ONLY, and allocated only by Intuition */
; 26.026   0  typedef struct IClass {
; 26.027   0      struct Hook		cl_Dispatcher;
; 26.028   0      ULONG		cl_Reserved;	/* must be 0  */
; 26.029   0      struct IClass	*cl_Super;
; 26.030   0      ClassID		cl_ID;
; 26.031
; 26.032          /* where within an object is the instance data for this class? */
; 26.033   0      UWORD		cl_InstOffset;

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 46
;
;
;Line#  Block                                  Source
; 26.034   0      UWORD		cl_InstSize;
; 26.035
; 26.036   0      ULONG		cl_UserData;	/* per-class data of your choice */
; 26.037   0      ULONG		cl_SubclassCount;
; 26.038      					/* how many direct subclasses?	*/
; 26.039   0      ULONG		cl_ObjectCount;
; 26.040      				/* how many objects created of this class? */
; 26.041   0      ULONG		cl_Flags;
; 26.042   0  #define	CLF_INLIST	0x00000001	/* class is in public class list */
; 26.043   0  } Class;
; 26.044
; 26.045      /* add offset for instance data to an object handle */
; 26.046   0  #define INST_DATA( cl, o )	((VOID *) (((UBYTE *)o)+cl->cl_InstOffset))
; 26.047
; 26.048      /* sizeof the instance data for a given class */
; 26.050   0  			+ sizeof (struct _Object ))
; 26.051
; 26.052      /**************************************************/
; 26.053      /*** "White box" access to struct _Object	***/
; 26.054      /**************************************************/
; 26.055
; 26.056      /*
; 26.057       * We have this, the instance data of the root class, PRECEDING
; 26.058       * the "object".  This is so that Gadget objects are Gadget pointers,
; 26.059       * and so on.  If this structure grows, it will always have o_Class
; 26.060       * at the end, so the macro OCLASS(o) will always have the same
; 26.061       * offset back from the pointer returned from NewObject().
; 26.062       *
; 26.063       * This data structure is subject to change.  Do not use the o_Node
; 26.064       * embedded structure.
; 26.065       */
; 26.066   0  struct _Object {
; 26.067   0      struct MinNode	o_Node;
; 26.068   0      struct IClass	*o_Class;
; 26.069   0  };
; 26.070
; 26.071      /* convenient typecast	*/
; 26.072   0  #define _OBJ( o )	((struct _Object *)(o))
; 26.073
; 26.074      /* get "public" handle on baseclass instance from real beginning of obj data */
; 26.075   0  #define BASEOBJECT( _obj )	( (Object *) (_OBJ(_obj)+1) )
; 26.076
; 26.077      /* get back to object data struct from public handle */
; 26.078   0  #define _OBJECT( o )		(_OBJ(o) - 1)
; 26.079
; 26.080      /* get class pointer from an object handle	*/
; 26.081   0  #define OCLASS( o )	( (_OBJECT(o))->o_Class )
; 26.082
; 26.083   0  #endif
; 19.031   0  #endif

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 47
;
;
;Line#  Block                                  Source
; 19.032   0  #ifndef  INTUITION_CLASSUSR_H
; 19.033      #include <intuition/classusr.h>
; 19.034      #endif
; 19.035   0  #ifndef  GRAPHICS_GRAPHINT_H
; 19.036   0  #include <graphics/graphint.h>
;===> Including file "sc:include/graphics/graphint.h"
; 28.001   0  #ifndef	GRAPHICS_GRAPHINT_H
; 28.002   0  #define	GRAPHICS_GRAPHINT_H
; 28.003      /*
; 28.004      **	$VER: graphint.h 39.0 (23.9.91)
; 28.005      **	Includes Release 40.13
; 28.006      **
; 28.007      **
; 28.008      **
; 28.009      **	(C) Copyright 1985-1993 Commodore-Amiga, Inc.
; 28.010      **	    All Rights Reserved
; 28.011      */
; 28.012
; 28.013   0  #ifndef EXEC_NODES_H
; 28.014      #include <exec/nodes.h>
; 28.015      #endif
; 28.016
; 28.017      /* structure used by AddTOFTask */
; 28.018   0  struct Isrvstr
; 28.019   0  {
; 28.020   0      struct Node is_Node;
; 28.021   0      struct Isrvstr *Iptr;   /* passed to srvr by os */
; 28.022   0      int (*code)();
; 28.023   0      int (*ccode)();
; 28.024   0      int Carg;
; 28.025   0  };
; 28.026
; 28.027   0  #endif	/* GRAPHICS_GRAPHINT_H */
; 19.037   0  #endif
; 19.038
; 19.039      /*  Exec support functions */
; 19.040
; 19.041   0  void BeginIO( struct IORequest *ioReq );
; 19.042   0  struct IORequest *CreateExtIO( struct MsgPort *port, long ioSize );
; 19.043   0  struct MsgPort *CreatePort( STRPTR name, long pri );
; 19.044   0  struct IOStdReq *CreateStdIO( struct MsgPort *port );
; 19.045   0  struct Task *CreateTask( STRPTR name, long pri, APTR initPC,
; 19.046   0  	unsigned long stackSize );
; 19.047   0  void DeleteExtIO( struct IORequest *ioReq );
; 19.048   0  void DeletePort( struct MsgPort *ioReq );
; 19.049   0  void DeleteStdIO( struct IOStdReq *ioReq );
; 19.050   0  void DeleteTask( struct Task *task );
; 19.051   0  void NewList( struct List *list );
; 19.052   0  APTR LibAllocPooled( APTR poolHeader, unsigned long memSize );
; 19.053   0  APTR LibCreatePool( unsigned long memFlags, unsigned long puddleSize,

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 48
;
;
;Line#  Block                                  Source
; 19.054   0  	unsigned long threshSize );
; 19.055   0  void LibDeletePool( APTR poolHeader );
; 19.056   0  void LibFreePooled( APTR poolHeader, APTR memory, unsigned long memSize );
; 19.057
; 19.058      /* Assorted functions in amiga.lib */
; 19.059
; 19.060   0  ULONG FastRand( unsigned long seed );
; 19.061   0  UWORD RangeRand( unsigned long maxValue );
; 19.062
; 19.063      /* Graphics support functions in amiga.lib */
; 19.064
; 19.065   0  void AddTOF( struct Isrvstr *i, long (*p)(), long a );
; 19.066   0  void RemTOF( struct Isrvstr *i );
; 19.067   0  void waitbeam( long b );
; 19.068
; 19.069      /* math support functions in amiga.lib */
; 19.070
; 19.071   0  FLOAT afp( BYTE *string );
; 19.072   0  void arnd( long place, long exp, BYTE *string );
; 19.073   0  FLOAT dbf( unsigned long exp, unsigned long mant );
; 19.074   0  LONG fpa( FLOAT fnum, BYTE *string );
; 19.075   0  void fpbcd( FLOAT fnum, BYTE *string );
; 19.076
; 19.077      /* Timer support functions in amiga.lib (V36 and higher only) */
; 19.078
; 19.079   0  LONG TimeDelay( long unit, unsigned long secs, unsigned long microsecs );
; 19.080   0  LONG DoTimer( struct timeval *, long unit, long command );
; 19.081
; 19.082      /*  Commodities functions in amiga.lib (V36 and higher only) */
; 19.083
; 19.084   0  void ArgArrayDone( void );
; 19.085   0  UBYTE **ArgArrayInit( long argc, UBYTE **argv );
; 19.086   0  LONG ArgInt( UBYTE **tt, STRPTR entry, long defaultval );
; 19.087   0  STRPTR ArgString( UBYTE **tt, STRPTR entry, STRPTR defaulstring );
; 19.088   0  CxObj *HotKey( STRPTR description, struct MsgPort *port, long id );
; 19.089   0  struct InputEvent *InvertString( STRPTR str, struct KeyMap *km );
; 19.090   0  void FreeIEvents( struct InputEvent *events );
; 19.091
; 19.092      /* Commodities Macros */
; 19.093
; 19.094      /* CxObj *CxCustom(LONG(*)(),LONG id)(A0,D0) */
; 19.095      /* CxObj *CxDebug(LONG id)(D0) */
; 19.096      /* CxObj *CxFilter(STRPTR description)(A0) */
; 19.097      /* CxObj *CxSender(struct MsgPort *port,LONG id)(A0,D0) */
; 19.098      /* CxObj *CxSignal(struct Task *task,LONG signal)(A0,D0) */
; 19.099      /* CxObj *CxTranslate(struct InputEvent *ie)(A0) */
; 19.100
; 19.101      /*  ARexx support functions in amiga.lib */
; 19.102
; 19.103   0  BOOL CheckRexxMsg( struct Message *rexxmsg );

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 49
;
;
;Line#  Block                                  Source
; 19.104   0  LONG GetRexxVar( struct Message *rexxmsg, UBYTE *name, UBYTE **result );
; 19.105   0  LONG SetRexxVar( struct Message *rexxmsg, UBYTE *name, UBYTE *value,
; 19.106   0  	long length );
; 19.107
; 19.108      /*  Intuition hook and boopsi support functions in amiga.lib. */
; 19.109      /*  These functions do not require any particular ROM revision */
; 19.110      /*  to operate correctly, though they deal with concepts first introduced */
; 19.111      /*  in V36.  These functions would work with compatibly-implemented */
; 19.112      /*  hooks or objects under V34. */
; 19.113
; 19.114   0  ULONG CallHookA( struct Hook *hookPtr, Object *obj, APTR message );
; 19.115   0  ULONG CallHook( struct Hook *hookPtr, Object *obj, ... );
; 19.116   0  ULONG DoMethodA( Object *obj, Msg message );
; 19.117   0  ULONG DoMethod( Object *obj, unsigned long MethodID, ... );
; 19.118   0  ULONG DoSuperMethodA( struct IClass *cl, Object *obj, Msg message );
; 19.119   0  ULONG DoSuperMethod( struct IClass *cl, Object *obj, unsigned long MethodID,
; 19.120   0  	... );
; 19.121   0  ULONG CoerceMethodA( struct IClass *cl, Object *obj, Msg message );
; 19.122   0  ULONG CoerceMethod( struct IClass *cl, Object *obj, unsigned long MethodID,
; 19.123   0  	... );
; 19.124   0  ULONG SetSuperAttrs( struct IClass *cl, Object *obj, unsigned long Tag1,
; 19.125   0  	... );
; 19.126
; 19.127      /*  Network-support functions in amiga.lib. */
; 19.128      /*  ACrypt() first appeared in later V39 versions of amiga.lib, but */
; 19.129      /*  operates correctly under V37 and up. */
; 19.130
; 19.131   0  STRPTR ACrypt( STRPTR buffer, STRPTR password, STRPTR username );
; 19.132   0  #endif	 /* CLIB_ALIB_PROTOS_H */
; 14.015   0  #endif
; 13       0  #include <proto/dos.h>
;===> Including file "sc:include/proto/dos.h"
; 29.001   0  #ifndef PROTO_DOS_H
; 29.002   0  #define PROTO_DOS_H
; 29.003   0  #include <exec/types.h>
; 29.004   0  extern struct DosLibrary *DOSBase ;
; 29.005   0  #include <clib/dos_protos.h>
;===> Including file "sc:include/clib/dos_protos.h"
; 30.001   0  #ifndef  CLIB_DOS_PROTOS_H
; 30.002   0  #define  CLIB_DOS_PROTOS_H
; 30.003
; 30.004      /*
; 30.005      **	$VER: dos_protos.h 36.31 (17.12.92)
; 30.006      **	Includes Release 40.13
; 30.007      **
; 30.008      **	C prototypes. For use with 32 bit integers only.
; 30.009      **
; 30.010      **	(C) Copyright 1990-1993 Commodore-Amiga, Inc.
; 30.011      **	    All Rights Reserved
; 30.012      */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 50
;
;
;Line#  Block                                  Source
; 30.013
; 30.014   0  #ifndef  DOS_DOS_H
; 30.015   0  #include <dos/dos.h>
;===> Including file "sc:include/dos/dos.h"
; 31.001   0  #ifndef DOS_DOS_H
; 31.002   0  #define DOS_DOS_H
; 31.003      /*
; 31.004      **	$VER: dos.h 36.27 (5.4.92)
; 31.005      **	Includes Release 40.13
; 31.006      **
; 31.007      **	Standard C header for AmigaDOS
; 31.008      **
; 31.009      **	(C) Copyright 1985-1993 Commodore-Amiga, Inc.
; 31.010      **	    All Rights Reserved
; 31.011      */
; 31.012
; 31.013   0  #ifndef EXEC_TYPES_H
; 31.014      #include "exec/types.h"
; 31.015      #endif
; 31.016
; 31.017
; 31.018   0  #define	 DOSNAME  "dos.library"
; 31.019
; 31.020      /* Predefined Amiga DOS global constants */
; 31.021
; 31.022   0  #define DOSTRUE (-1L)
; 31.023   0  #define DOSFALSE (0L)
; 31.024
; 31.025      /* Mode parameter to Open() */
; 31.026   0  #define MODE_OLDFILE	     1005   /* Open existing file read/write
; 31.027   0  				     * positioned at beginning of file. */
; 31.028   0  #define MODE_NEWFILE	     1006   /* Open freshly created file (delete
; 31.029   0  				     * old file) read/write, exclusive lock. */
; 31.030   0  #define MODE_READWRITE	     1004   /* Open old file w/shared lock,
; 31.031   0  				     * creates file if doesn't exist. */
; 31.032
; 31.033      /* Relative position to Seek() */
; 31.034   0  #define OFFSET_BEGINNING    -1	    /* relative to Begining Of File */
; 31.035   0  #define OFFSET_CURRENT	     0	    /* relative to Current file position */
; 31.036   0  #define OFFSET_END	     1	    /* relative to End Of File	  */
; 31.037
; 31.038   0  #define OFFSET_BEGINING	    OFFSET_BEGINNING  /* ancient compatibility */
; 31.039
; 31.040   0  #define BITSPERBYTE	     8
; 31.041   0  #define BYTESPERLONG	     4
; 31.042   0  #define BITSPERLONG	     32
; 31.043   0  #define MAXINT		     0x7FFFFFFF
; 31.044   0  #define MININT		     0x80000000
; 31.045
; 31.046      /* Passed as type to Lock() */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 51
;
;
;Line#  Block                                  Source
; 31.047   0  #define SHARED_LOCK	     -2	    /* File is readable by others */
; 31.048   0  #define ACCESS_READ	     -2	    /* Synonym */
; 31.049   0  #define EXCLUSIVE_LOCK	     -1	    /* No other access allowed	  */
; 31.050   0  #define ACCESS_WRITE	     -1	    /* Synonym */
; 31.051
; 31.052   0  struct DateStamp {
; 31.053   0     LONG	 ds_Days;	      /* Number of days since Jan. 1, 1978 */
; 31.054   0     LONG	 ds_Minute;	      /* Number of minutes past midnight */
; 31.055   0     LONG	 ds_Tick;	      /* Number of ticks past minute */
; 31.056   0  }; /* DateStamp */
; 31.057
; 31.058   0  #define TICKS_PER_SECOND      50   /* Number of ticks in one second */
; 31.059
; 31.060      /* Returned by Examine() and ExNext(), must be on a 4 byte boundary */
; 31.061   0  struct FileInfoBlock {
; 31.062   0     LONG	  fib_DiskKey;
; 31.063   0     LONG	  fib_DirEntryType;  /* Type of Directory. If < 0, then a plain file.
; 31.064   0  			      * If > 0 a directory */
; 31.065   0     char	  fib_FileName[108]; /* Null terminated. Max 30 chars used for now */
; 31.066   0     LONG	  fib_Protection;    /* bit mask of protection, rwxd are 3-0.	   */
; 31.067   0     LONG	  fib_EntryType;
; 31.068   0     LONG	  fib_Size;	     /* Number of bytes in file */
; 31.069   0     LONG	  fib_NumBlocks;     /* Number of blocks in file */
; 31.070   0     struct DateStamp fib_Date;/* Date file last changed */
; 31.071   0     char	  fib_Comment[80];  /* Null terminated comment associated with file */
; 31.072
; 31.073         /* Note: the following fields are not supported by all filesystems.	*/
; 31.074         /* They should be initialized to 0 sending an ACTION_EXAMINE packet.	*/
; 31.075         /* When Examine() is called, these are set to 0 for you.		*/
; 31.076         /* AllocDosObject() also initializes them to 0.			*/
; 31.077   0     UWORD  fib_OwnerUID;		/* owner's UID */
; 31.078   0     UWORD  fib_OwnerGID;		/* owner's GID */
; 31.079
; 31.080   0     char	  fib_Reserved[32];
; 31.081   0  }; /* FileInfoBlock */
; 31.082
; 31.083      /* FIB stands for FileInfoBlock */
; 31.084
; 31.085      /* FIBB are bit definitions, FIBF are field definitions */
; 31.086      /* Regular RWED bits are 0 == allowed. */
; 31.087      /* NOTE: GRP and OTR RWED permissions are 0 == not allowed! */
; 31.088      /* Group and Other permissions are not directly handled by the filesystem */
; 31.089   0  #define FIBB_OTR_READ	   15	/* Other: file is readable */
; 31.090   0  #define FIBB_OTR_WRITE	   14	/* Other: file is writable */
; 31.091   0  #define FIBB_OTR_EXECUTE   13	/* Other: file is executable */
; 31.092   0  #define FIBB_OTR_DELETE    12	/* Other: prevent file from being deleted */
; 31.093   0  #define FIBB_GRP_READ	   11	/* Group: file is readable */
; 31.094   0  #define FIBB_GRP_WRITE	   10	/* Group: file is writable */
; 31.095   0  #define FIBB_GRP_EXECUTE   9	/* Group: file is executable */
; 31.096   0  #define FIBB_GRP_DELETE    8	/* Group: prevent file from being deleted */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 52
;
;
;Line#  Block                                  Source
; 31.097
; 31.098   0  #define FIBB_SCRIPT    6	/* program is a script (execute) file */
; 31.099   0  #define FIBB_PURE      5	/* program is reentrant and rexecutable */
; 31.100   0  #define FIBB_ARCHIVE   4	/* cleared whenever file is changed */
; 31.101   0  #define FIBB_READ      3	/* ignored by old filesystem */
; 31.102   0  #define FIBB_WRITE     2	/* ignored by old filesystem */
; 31.103   0  #define FIBB_EXECUTE   1	/* ignored by system, used by Shell */
; 31.104   0  #define FIBB_DELETE    0	/* prevent file from being deleted */
; 31.105
; 31.106   0  #define FIBF_OTR_READ	   (1<<FIBB_OTR_READ)
; 31.107   0  #define FIBF_OTR_WRITE	   (1<<FIBB_OTR_WRITE)
; 31.108   0  #define FIBF_OTR_EXECUTE   (1<<FIBB_OTR_EXECUTE)
; 31.109   0  #define FIBF_OTR_DELETE    (1<<FIBB_OTR_DELETE)
; 31.110   0  #define FIBF_GRP_READ	   (1<<FIBB_GRP_READ)
; 31.111   0  #define FIBF_GRP_WRITE	   (1<<FIBB_GRP_WRITE)
; 31.112   0  #define FIBF_GRP_EXECUTE   (1<<FIBB_GRP_EXECUTE)
; 31.113   0  #define FIBF_GRP_DELETE    (1<<FIBB_GRP_DELETE)
; 31.114
; 31.115   0  #define FIBF_SCRIPT    (1<<FIBB_SCRIPT)
; 31.116   0  #define FIBF_PURE      (1<<FIBB_PURE)
; 31.117   0  #define FIBF_ARCHIVE   (1<<FIBB_ARCHIVE)
; 31.118   0  #define FIBF_READ      (1<<FIBB_READ)
; 31.119   0  #define FIBF_WRITE     (1<<FIBB_WRITE)
; 31.120   0  #define FIBF_EXECUTE   (1<<FIBB_EXECUTE)
; 31.121   0  #define FIBF_DELETE    (1<<FIBB_DELETE)
; 31.122
; 31.123      /* Standard maximum length for an error string from fault.  However, most */
; 31.124      /* error strings should be kept under 60 characters if possible.  Don't   */
; 31.125      /* forget space for the header you pass in. */
; 31.126   0  #define FAULT_MAX	82
; 31.127
; 31.128      /* All BCPL data must be long word aligned.  BCPL pointers are the long word
; 31.129       *  address (i.e byte address divided by 4 (>>2)) */
; 31.130   0  typedef long  BPTR;		    /* Long word pointer */
; 31.131   0  typedef long  BSTR;		    /* Long word pointer to BCPL string	 */
; 31.132
; 31.133      /* Convert BPTR to typical C pointer */
; 31.134   0  #ifdef OBSOLETE_LIBRARIES_DOS_H
; 31.135      #define BADDR( bptr )	(((ULONG)bptr) << 2)
; 31.136      #else
; 31.137      /* This one has no problems with CASTing */
; 31.138   0  #define BADDR(x)	((APTR)((ULONG)(x) << 2))
; 31.139   0  #endif
; 31.140      /* Convert address into a BPTR */
; 31.141   0  #define MKBADDR(x)	(((LONG)(x)) >> 2)
; 31.142
; 31.143      /* BCPL strings have a length in the first byte and then the characters.
; 31.144       * For example:	 s[0]=3 s[1]=S s[2]=Y s[3]=S				 */
; 31.145
; 31.146      /* returned by Info(), must be on a 4 byte boundary */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 53
;
;
;Line#  Block                                  Source
; 31.147   0  struct InfoData {
; 31.148   0     LONG	  id_NumSoftErrors;	/* number of soft errors on disk */
; 31.149   0     LONG	  id_UnitNumber;	/* Which unit disk is (was) mounted on */
; 31.150   0     LONG	  id_DiskState;		/* See defines below */
; 31.151   0     LONG	  id_NumBlocks;		/* Number of blocks on disk */
; 31.152   0     LONG	  id_NumBlocksUsed;	/* Number of block in use */
; 31.153   0     LONG	  id_BytesPerBlock;
; 31.154   0     LONG	  id_DiskType;		/* Disk Type code */
; 31.155   0     BPTR	  id_VolumeNode;	/* BCPL pointer to volume node */
; 31.156   0     LONG	  id_InUse;		/* Flag, zero if not in use */
; 31.157   0  }; /* InfoData */
; 31.158
; 31.159      /* ID stands for InfoData */
; 31.160      	/* Disk states */
; 31.161   0  #define ID_WRITE_PROTECTED 80	 /* Disk is write protected */
; 31.162   0  #define ID_VALIDATING	   81	 /* Disk is currently being validated */
; 31.163   0  #define ID_VALIDATED	   82	 /* Disk is consistent and writeable */
; 31.164
; 31.165      	/* Disk types */
; 31.166      /* ID_INTER_* use international case comparison routines for hashing */
; 31.167      /* Any other new filesystems should also, if possible. */
; 31.168   0  #define ID_NO_DISK_PRESENT	(-1)
; 31.169   0  #define ID_UNREADABLE_DISK	(0x42414400L)	/* 'BAD\0' */
; 31.170   0  #define ID_DOS_DISK		(0x444F5300L)	/* 'DOS\0' */
; 31.171   0  #define ID_FFS_DISK		(0x444F5301L)	/* 'DOS\1' */
; 31.172   0  #define ID_INTER_DOS_DISK	(0x444F5302L)	/* 'DOS\2' */
; 31.173   0  #define ID_INTER_FFS_DISK	(0x444F5303L)	/* 'DOS\3' */
; 31.174   0  #define ID_FASTDIR_DOS_DISK	(0x444F5304L)	/* 'DOS\4' */
; 31.175   0  #define ID_FASTDIR_FFS_DISK	(0x444F5305L)	/* 'DOS\5' */
; 31.176   0  #define ID_NOT_REALLY_DOS	(0x4E444F53L)	/* 'NDOS'  */
; 31.177   0  #define ID_KICKSTART_DISK	(0x4B49434BL)	/* 'KICK'  */
; 31.178   0  #define ID_MSDOS_DISK		(0x4d534400L)	/* 'MSD\0' */
; 31.179
; 31.180      /* Errors from IoErr(), etc. */
; 31.181   0  #define ERROR_NO_FREE_STORE		  103
; 31.182   0  #define ERROR_TASK_TABLE_FULL		  105
; 31.183   0  #define ERROR_BAD_TEMPLATE		  114
; 31.184   0  #define ERROR_BAD_NUMBER		  115
; 31.185   0  #define ERROR_REQUIRED_ARG_MISSING	  116
; 31.186   0  #define ERROR_KEY_NEEDS_ARG		  117
; 31.187   0  #define ERROR_TOO_MANY_ARGS		  118
; 31.188   0  #define ERROR_UNMATCHED_QUOTES		  119
; 31.189   0  #define ERROR_LINE_TOO_LONG		  120
; 31.190   0  #define ERROR_FILE_NOT_OBJECT		  121
; 31.191   0  #define ERROR_INVALID_RESIDENT_LIBRARY	  122
; 31.192   0  #define ERROR_NO_DEFAULT_DIR		  201
; 31.193   0  #define ERROR_OBJECT_IN_USE		  202
; 31.194   0  #define ERROR_OBJECT_EXISTS		  203
; 31.195   0  #define ERROR_DIR_NOT_FOUND		  204
; 31.196   0  #define ERROR_OBJECT_NOT_FOUND		  205

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 54
;
;
;Line#  Block                                  Source
; 31.197   0  #define ERROR_BAD_STREAM_NAME		  206
; 31.198   0  #define ERROR_OBJECT_TOO_LARGE		  207
; 31.199   0  #define ERROR_ACTION_NOT_KNOWN		  209
; 31.200   0  #define ERROR_INVALID_COMPONENT_NAME	  210
; 31.201   0  #define ERROR_INVALID_LOCK		  211
; 31.202   0  #define ERROR_OBJECT_WRONG_TYPE		  212
; 31.203   0  #define ERROR_DISK_NOT_VALIDATED	  213
; 31.204   0  #define ERROR_DISK_WRITE_PROTECTED	  214
; 31.205   0  #define ERROR_RENAME_ACROSS_DEVICES	  215
; 31.206   0  #define ERROR_DIRECTORY_NOT_EMPTY	  216
; 31.207   0  #define ERROR_TOO_MANY_LEVELS		  217
; 31.208   0  #define ERROR_DEVICE_NOT_MOUNTED	  218
; 31.209   0  #define ERROR_SEEK_ERROR		  219
; 31.210   0  #define ERROR_COMMENT_TOO_BIG		  220
; 31.211   0  #define ERROR_DISK_FULL			  221
; 31.212   0  #define ERROR_DELETE_PROTECTED		  222
; 31.213   0  #define ERROR_WRITE_PROTECTED		  223
; 31.214   0  #define ERROR_READ_PROTECTED		  224
; 31.215   0  #define ERROR_NOT_A_DOS_DISK		  225
; 31.216   0  #define ERROR_NO_DISK			  226
; 31.217   0  #define ERROR_NO_MORE_ENTRIES		  232
; 31.218      /* added for 1.4 */
; 31.219   0  #define ERROR_IS_SOFT_LINK		  233
; 31.220   0  #define ERROR_OBJECT_LINKED		  234
; 31.221   0  #define ERROR_BAD_HUNK			  235
; 31.222   0  #define ERROR_NOT_IMPLEMENTED		  236
; 31.223   0  #define ERROR_RECORD_NOT_LOCKED		  240
; 31.224   0  #define ERROR_LOCK_COLLISION		  241
; 31.225   0  #define ERROR_LOCK_TIMEOUT		  242
; 31.226   0  #define ERROR_UNLOCK_ERROR		  243
; 31.227
; 31.228      /* error codes 303-305 are defined in dosasl.h */
; 31.229
; 31.230      /* These are the return codes used by convention by AmigaDOS commands */
; 31.231      /* See FAILAT and IF for relvance to EXECUTE files		      */
; 31.232   0  #define RETURN_OK			    0  /* No problems, success */
; 31.233   0  #define RETURN_WARN			    5  /* A warning only */
; 31.234   0  #define RETURN_ERROR			   10  /* Something wrong */
; 31.235   0  #define RETURN_FAIL			   20  /* Complete or severe failure*/
; 31.236
; 31.237      /* Bit numbers that signal you that a user has issued a break */
; 31.238   0  #define SIGBREAKB_CTRL_C   12
; 31.239   0  #define SIGBREAKB_CTRL_D   13
; 31.240   0  #define SIGBREAKB_CTRL_E   14
; 31.241   0  #define SIGBREAKB_CTRL_F   15
; 31.242
; 31.243      /* Bit fields that signal you that a user has issued a break */
; 31.244      /* for example:	 if (SetSignal(0,0) & SIGBREAKF_CTRL_C) cleanup_and_exit(); */
; 31.245   0  #define SIGBREAKF_CTRL_C   (1<<SIGBREAKB_CTRL_C)
; 31.246   0  #define SIGBREAKF_CTRL_D   (1<<SIGBREAKB_CTRL_D)

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 55
;
;
;Line#  Block                                  Source
; 31.247   0  #define SIGBREAKF_CTRL_E   (1<<SIGBREAKB_CTRL_E)
; 31.248   0  #define SIGBREAKF_CTRL_F   ((long)1<<SIGBREAKB_CTRL_F)
; 31.249
; 31.250      /* Values returned by SameLock() */
; 31.251   0  #define LOCK_DIFFERENT		-1
; 31.252   0  #define LOCK_SAME		0
; 31.253   0  #define LOCK_SAME_VOLUME	1	/* locks are on same volume */
; 31.254   0  #define LOCK_SAME_HANDLER	LOCK_SAME_VOLUME
; 31.255      /* LOCK_SAME_HANDLER was a misleading name, def kept for src compatibility */
; 31.256
; 31.257      /* types for ChangeMode() */
; 31.258   0  #define CHANGE_LOCK	0
; 31.259   0  #define CHANGE_FH	1
; 31.260
; 31.261      /* Values for MakeLink() */
; 31.262   0  #define LINK_HARD	0
; 31.263   0  #define LINK_SOFT	1	/* softlinks are not fully supported yet */
; 31.264
; 31.265      /* values returned by ReadItem */
; 31.266   0  #define	ITEM_EQUAL	-2		/* "=" Symbol */
; 31.267   0  #define ITEM_ERROR	-1		/* error */
; 31.268   0  #define ITEM_NOTHING	0		/* *N, ;, endstreamch */
; 31.269   0  #define ITEM_UNQUOTED	1		/* unquoted item */
; 31.270   0  #define ITEM_QUOTED	2		/* quoted item */
; 31.271
; 31.272      /* types for AllocDosObject/FreeDosObject */
; 31.273   0  #define DOS_FILEHANDLE		0	/* few people should use this */
; 31.274   0  #define DOS_EXALLCONTROL	1	/* Must be used to allocate this! */
; 31.275   0  #define	DOS_FIB			2	/* useful */
; 31.276   0  #define DOS_STDPKT		3	/* for doing packet-level I/O */
; 31.277   0  #define DOS_CLI			4	/* for shell-writers, etc */
; 31.278   0  #define DOS_RDARGS		5	/* for ReadArgs if you pass it in */
; 31.279
; 31.280   0  #endif	/* DOS_DOS_H */
; 31.281
; 30.016   0  #endif
; 30.017   0  #ifndef  DOS_DOSEXTENS_H
; 30.018   0  #include <dos/dosextens.h>
;===> Including file "sc:include/dos/dosextens.h"
; 32.001   0  #ifndef DOS_DOSEXTENS_H
; 32.002   0  #define DOS_DOSEXTENS_H
; 32.003      /*
; 32.004      **	$VER: dosextens.h 36.41 (14.5.92)
; 32.005      **	Includes Release 40.13
; 32.006      **
; 32.007      **	DOS structures not needed for the casual AmigaDOS user
; 32.008      **
; 32.009      **	(C) Copyright 1985-1993 Commodore-Amiga, Inc.
; 32.010      **	    All Rights Reserved
; 32.011      */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 56
;
;
;Line#  Block                                  Source
; 32.012
; 32.013   0  #ifndef EXEC_TASKS_H
; 32.014      #include "exec/tasks.h"
; 32.015      #endif
; 32.016   0  #ifndef EXEC_PORTS_H
; 32.017      #include "exec/ports.h"
; 32.018      #endif
; 32.019   0  #ifndef EXEC_LIBRARIES_H
; 32.020   0  #include "exec/libraries.h"
;===> Including file "sc:include/exec/libraries.h"
; 33.001   0  #ifndef	EXEC_LIBRARIES_H
; 33.002   0  #define	EXEC_LIBRARIES_H
; 33.003      /*
; 33.004      **	$VER: libraries.h 39.2 (10.4.92)
; 33.005      **	Includes Release 40.13
; 33.006      **
; 33.007      **	Definitions for use when creating or using Exec libraries
; 33.008      **
; 33.009      **	(C) Copyright 1985-1993 Commodore-Amiga, Inc.
; 33.010      **	    All Rights Reserved
; 33.011      */
; 33.012
; 33.013   0  #ifndef EXEC_NODES_H
; 33.014      #include "exec/nodes.h"
; 33.015      #endif /* EXEC_NODES_H */
; 33.016
; 33.017
; 33.018      /*------ Special Constants ---------------------------------------*/
; 33.019   0  #define LIB_VECTSIZE	6	/* Each library entry takes 6 bytes */
; 33.020   0  #define LIB_RESERVED	4	/* Exec reserves the first 4 vectors */
; 33.021   0  #define LIB_BASE	(-LIB_VECTSIZE)
; 33.022   0  #define LIB_USERDEF	(LIB_BASE-(LIB_RESERVED*LIB_VECTSIZE))
; 33.023   0  #define LIB_NONSTD	(LIB_USERDEF)
; 33.024
; 33.025      /*------ Standard Functions --------------------------------------*/
; 33.026   0  #define LIB_OPEN	(-6)
; 33.027   0  #define LIB_CLOSE	(-12)
; 33.028   0  #define LIB_EXPUNGE	(-18)
; 33.029   0  #define LIB_EXTFUNC	(-24)	/* for future expansion */
; 33.030
; 33.031
; 33.032      /*------ Library Base Structure ----------------------------------*/
; 33.033      /* Also used for Devices and some Resources */
; 33.034   0  struct Library {
; 33.035   0      struct  Node lib_Node;
; 33.036   0      UBYTE   lib_Flags;
; 33.037   0      UBYTE   lib_pad;
; 33.038   0      UWORD   lib_NegSize;	    /* number of bytes before library */
; 33.039   0      UWORD   lib_PosSize;	    /* number of bytes after library */
; 33.040   0      UWORD   lib_Version;	    /* major */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 57
;
;
;Line#  Block                                  Source
; 33.041   0      UWORD   lib_Revision;	    /* minor */
; 33.042   0      APTR    lib_IdString;	    /* ASCII identification */
; 33.043   0      ULONG   lib_Sum;		    /* the checksum itself */
; 33.044   0      UWORD   lib_OpenCnt;	    /* number of current opens */
; 33.045   0  };	/* Warning: size is not a longword multiple! */
; 33.046
; 33.047      /* lib_Flags bit definitions (all others are system reserved) */
; 33.048   0  #define LIBF_SUMMING	(1<<0)	    /* we are currently checksumming */
; 33.049   0  #define LIBF_CHANGED	(1<<1)	    /* we have just changed the lib */
; 33.050   0  #define LIBF_SUMUSED	(1<<2)	    /* set if we should bother to sum */
; 33.051   0  #define LIBF_DELEXP	(1<<3)	    /* delayed expunge */
; 33.052
; 33.053
; 33.054      /* Temporary Compatibility */
; 33.055   0  #define lh_Node	lib_Node
; 33.056   0  #define lh_Flags	lib_Flags
; 33.057   0  #define lh_pad		lib_pad
; 33.058   0  #define lh_NegSize	lib_NegSize
; 33.059   0  #define lh_PosSize	lib_PosSize
; 33.060   0  #define lh_Version	lib_Version
; 33.061   0  #define lh_Revision	lib_Revision
; 33.062   0  #define lh_IdString	lib_IdString
; 33.063   0  #define lh_Sum		lib_Sum
; 33.064   0  #define lh_OpenCnt	lib_OpenCnt
; 33.065
; 33.066   0  #endif	/* EXEC_LIBRARIES_H */
; 32.021   0  #endif
; 32.022   0  #ifndef EXEC_SEMAPHORES_H
; 32.023   0  #include "exec/semaphores.h"
;===> Including file "sc:include/exec/semaphores.h"
; 34.001   0  #ifndef	EXEC_SEMAPHORES_H
; 34.002   0  #define	EXEC_SEMAPHORES_H
; 34.003      /*
; 34.004      **	$VER: semaphores.h 39.1 (7.2.92)
; 34.005      **	Includes Release 40.13
; 34.006      **
; 34.007      **	Definitions for locking functions.
; 34.008      **
; 34.009      **	(C) Copyright 1986-1993 Commodore-Amiga, Inc.
; 34.010      **	    All Rights Reserved
; 34.011      */
; 34.012
; 34.013   0  #ifndef EXEC_NODES_H
; 34.014      #include "exec/nodes.h"
; 34.015      #endif /* EXEC_NODES_H */
; 34.016
; 34.017   0  #ifndef EXEC_LISTS_H
; 34.018      #include "exec/lists.h"
; 34.019      #endif /* EXEC_LISTS_H */
; 34.020

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 58
;
;
;Line#  Block                                  Source
; 34.021   0  #ifndef EXEC_PORTS_H
; 34.022      #include "exec/ports.h"
; 34.023      #endif /* EXEC_PORTS_H */
; 34.024
; 34.025   0  #ifndef EXEC_TASKS_H
; 34.026      #include "exec/tasks.h"
; 34.027      #endif /* EXEC_TASKS_H */
; 34.028
; 34.029
; 34.030      /****** SignalSemaphore *********************************************/
; 34.031
; 34.032      /* Private structure used by ObtainSemaphore() */
; 34.033   0  struct SemaphoreRequest
; 34.034   0  {
; 34.035   0  struct	MinNode	sr_Link;
; 34.036   0  struct	Task	*sr_Waiter;
; 34.037   0  };
; 34.038
; 34.039      /* Signal Semaphore data structure */
; 34.040   0  struct SignalSemaphore
; 34.041   0  {
; 34.042   0  struct	Node			ss_Link;
; 34.043   0  	WORD			ss_NestCount;
; 34.044   0  struct	MinList			ss_WaitQueue;
; 34.045   0  struct	SemaphoreRequest	ss_MultipleLink;
; 34.046   0  struct	Task			*ss_Owner;
; 34.047   0  	WORD			ss_QueueCount;
; 34.048   0  };
; 34.049
; 34.050      /****** Semaphore procure message (for use in V39 Procure/Vacate ****/
; 34.051   0  struct SemaphoreMessage
; 34.052   0  {
; 34.053   0  struct	Message		ssm_Message;
; 34.054   0  struct	SignalSemaphore	*ssm_Semaphore;
; 34.055   0  };
; 34.056
; 34.057   0  #define	SM_SHARED	(1L)
; 34.058   0  #define	SM_EXCLUSIVE	(0L)
; 34.059
; 34.060      /****** Semaphore (Old Procure/Vacate type, not reliable) ***********/
; 34.061
; 34.062   0  struct Semaphore	/* Do not use these semaphores! */
; 34.063   0  {
; 34.064   0  struct	MsgPort	sm_MsgPort;
; 34.065   0  	WORD	sm_Bids;
; 34.066   0  };
; 34.067
; 34.068   0  #define sm_LockMsg	mp_SigTask
; 34.069
; 34.070

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 59
;
;
;Line#  Block                                  Source
; 34.071   0  #endif	/* EXEC_SEMAPHORES_H */
; 32.024   0  #endif
; 32.025   0  #ifndef DEVICES_TIMER_H
; 32.026      #include "devices/timer.h"
; 32.027      #endif
; 32.028
; 32.029   0  #ifndef DOS_DOS_H
; 32.030      #include "dos/dos.h"
; 32.031      #endif
; 32.032
; 32.033      /* All DOS processes have this structure */
; 32.034      /* Create and Device Proc returns pointer to the MsgPort in this structure */
; 32.035      /* dev_proc = (struct Process *) (DeviceProc(..) - sizeof(struct Task)); */
; 32.036
; 32.037   0  struct Process {
; 32.038   0      struct  Task    pr_Task;
; 32.039   0      struct  MsgPort pr_MsgPort; /* This is BPTR address from DOS functions  */
; 32.040   0      WORD    pr_Pad;		/* Remaining variables on 4 byte boundaries */
; 32.041   0      BPTR    pr_SegList;		/* Array of seg lists used by this process  */
; 32.042   0      LONG    pr_StackSize;	/* Size of process stack in bytes	    */
; 32.043   0      APTR    pr_GlobVec;		/* Global vector for this process (BCPL)    */
; 32.044   0      LONG    pr_TaskNum;		/* CLI task number of zero if not a CLI	    */
; 32.045   0      BPTR    pr_StackBase;	/* Ptr to high memory end of process stack  */
; 32.046   0      LONG    pr_Result2;		/* Value of secondary result from last call */
; 32.047   0      BPTR    pr_CurrentDir;	/* Lock associated with current directory   */
; 32.048   0      BPTR    pr_CIS;		/* Current CLI Input Stream		    */
; 32.049   0      BPTR    pr_COS;		/* Current CLI Output Stream		    */
; 32.050   0      APTR    pr_ConsoleTask;	/* Console handler process for current window*/
; 32.051   0      APTR    pr_FileSystemTask;	/* File handler process for current drive   */
; 32.052   0      BPTR    pr_CLI;		/* pointer to CommandLineInterface	    */
; 32.053   0      APTR    pr_ReturnAddr;	/* pointer to previous stack frame	    */
; 32.054   0      APTR    pr_PktWait;		/* Function to be called when awaiting msg  */
; 32.055   0      APTR    pr_WindowPtr;	/* Window for error printing		    */
; 32.056
; 32.057          /* following definitions are new with 2.0 */
; 32.058   0      BPTR    pr_HomeDir;		/* Home directory of executing program	    */
; 32.059   0      LONG    pr_Flags;		/* flags telling dos about process	    */
; 32.060   0      void    (*pr_ExitCode)();	/* code to call on exit of program or NULL  */
; 32.061   0      LONG    pr_ExitData;	/* Passed as an argument to pr_ExitCode.    */
; 32.062   0      UBYTE   *pr_Arguments;	/* Arguments passed to the process at start */
; 32.063   0      struct MinList pr_LocalVars; /* Local environment variables		    */
; 32.064   0      ULONG   pr_ShellPrivate;	/* for the use of the current shell	    */
; 32.065   0      BPTR    pr_CES;		/* Error stream - if NULL, use pr_COS	    */
; 32.066   0  };  /* Process */
; 32.067
; 32.068      /*
; 32.069       * Flags for pr_Flags
; 32.070       */
; 32.071   0  #define	PRB_FREESEGLIST		0
; 32.072   0  #define	PRF_FREESEGLIST		1

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 60
;
;
;Line#  Block                                  Source
; 32.073   0  #define	PRB_FREECURRDIR		1
; 32.074   0  #define	PRF_FREECURRDIR		2
; 32.075   0  #define	PRB_FREECLI		2
; 32.076   0  #define	PRF_FREECLI		4
; 32.077   0  #define	PRB_CLOSEINPUT		3
; 32.078   0  #define	PRF_CLOSEINPUT		8
; 32.079   0  #define	PRB_CLOSEOUTPUT		4
; 32.080   0  #define	PRF_CLOSEOUTPUT		16
; 32.081   0  #define	PRB_FREEARGS		5
; 32.082   0  #define	PRF_FREEARGS		32
; 32.083
; 32.084      /* The long word address (BPTR) of this structure is returned by
; 32.085       * Open() and other routines that return a file.  You need only worry
; 32.086       * about this struct to do async io's via PutMsg() instead of
; 32.087       * standard file system calls */
; 32.088
; 32.089   0  struct FileHandle {
; 32.090   0     struct Message *fh_Link;	 /* EXEC message	      */
; 32.091   0     struct MsgPort *fh_Port;	 /* Reply port for the packet */
; 32.092   0     struct MsgPort *fh_Type;	 /* Port to do PutMsg() to
; 32.093   0  				  * Address is negative if a plain file */
; 32.094   0     LONG fh_Buf;
; 32.095   0     LONG fh_Pos;
; 32.096   0     LONG fh_End;
; 32.097   0     LONG fh_Funcs;
; 32.098   0  #define fh_Func1 fh_Funcs
; 32.099   0     LONG fh_Func2;
; 32.100   0     LONG fh_Func3;
; 32.101   0     LONG fh_Args;
; 32.102   0  #define fh_Arg1 fh_Args
; 32.103   0     LONG fh_Arg2;
; 32.104   0  }; /* FileHandle */
; 32.105
; 32.106      /* This is the extension to EXEC Messages used by DOS */
; 32.107
; 32.108   0  struct DosPacket {
; 32.109   0     struct Message *dp_Link;	 /* EXEC message	      */
; 32.110   0     struct MsgPort *dp_Port;	 /* Reply port for the packet */
; 32.111      				 /* Must be filled in each send. */
; 32.112   0     LONG dp_Type;		 /* See ACTION_... below and
; 32.113   0  				  * 'R' means Read, 'W' means Write to the
; 32.114   0  				  * file system */
; 32.115   0     LONG dp_Res1;		 /* For file system calls this is the result
; 32.116   0  				  * that would have been returned by the
; 32.117   0  				  * function, e.g. Write ('W') returns actual
; 32.118   0  				  * length written */
; 32.119   0     LONG dp_Res2;		 /* For file system calls this is what would
; 32.120   0  				  * have been returned by IoErr() */
; 32.121      /*  Device packets common equivalents */
; 32.122   0  #define dp_Action  dp_Type

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 61
;
;
;Line#  Block                                  Source
; 32.123   0  #define dp_Status  dp_Res1
; 32.124   0  #define dp_Status2 dp_Res2
; 32.125   0  #define dp_BufAddr dp_Arg1
; 32.126   0     LONG dp_Arg1;
; 32.127   0     LONG dp_Arg2;
; 32.128   0     LONG dp_Arg3;
; 32.129   0     LONG dp_Arg4;
; 32.130   0     LONG dp_Arg5;
; 32.131   0     LONG dp_Arg6;
; 32.132   0     LONG dp_Arg7;
; 32.133   0  }; /* DosPacket */
; 32.134
; 32.135      /* A Packet does not require the Message to be before it in memory, but
; 32.136       * for convenience it is useful to associate the two.
; 32.137       * Also see the function init_std_pkt for initializing this structure */
; 32.138
; 32.139   0  struct StandardPacket {
; 32.140   0     struct Message   sp_Msg;
; 32.141   0     struct DosPacket sp_Pkt;
; 32.142   0  }; /* StandardPacket */
; 32.143
; 32.144      /* Packet types */
; 32.145   0  #define ACTION_NIL		0
; 32.146   0  #define ACTION_STARTUP		0
; 32.147   0  #define ACTION_GET_BLOCK	2	/* OBSOLETE */
; 32.148   0  #define ACTION_SET_MAP		4
; 32.149   0  #define ACTION_DIE		5
; 32.150   0  #define ACTION_EVENT		6
; 32.151   0  #define ACTION_CURRENT_VOLUME	7
; 32.152   0  #define ACTION_LOCATE_OBJECT	8
; 32.153   0  #define ACTION_RENAME_DISK	9
; 32.154   0  #define ACTION_WRITE		'W'
; 32.155   0  #define ACTION_READ		'R'
; 32.156   0  #define ACTION_FREE_LOCK	15
; 32.157   0  #define ACTION_DELETE_OBJECT	16
; 32.158   0  #define ACTION_RENAME_OBJECT	17
; 32.159   0  #define ACTION_MORE_CACHE	18
; 32.160   0  #define ACTION_COPY_DIR		19
; 32.161   0  #define ACTION_WAIT_CHAR	20
; 32.162   0  #define ACTION_SET_PROTECT	21
; 32.163   0  #define ACTION_CREATE_DIR	22
; 32.164   0  #define ACTION_EXAMINE_OBJECT	23
; 32.165   0  #define ACTION_EXAMINE_NEXT	24
; 32.166   0  #define ACTION_DISK_INFO	25
; 32.167   0  #define ACTION_INFO		26
; 32.168   0  #define ACTION_FLUSH		27
; 32.169   0  #define ACTION_SET_COMMENT	28
; 32.170   0  #define ACTION_PARENT		29
; 32.171   0  #define ACTION_TIMER		30
; 32.172   0  #define ACTION_INHIBIT		31

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 62
;
;
;Line#  Block                                  Source
; 32.173   0  #define ACTION_DISK_TYPE	32
; 32.174   0  #define ACTION_DISK_CHANGE	33
; 32.175   0  #define ACTION_SET_DATE		34
; 32.176
; 32.177   0  #define ACTION_SCREEN_MODE	994
; 32.178
; 32.179   0  #define ACTION_READ_RETURN	1001
; 32.180   0  #define ACTION_WRITE_RETURN	1002
; 32.181   0  #define ACTION_SEEK		1008
; 32.182   0  #define ACTION_FINDUPDATE	1004
; 32.183   0  #define ACTION_FINDINPUT	1005
; 32.184   0  #define ACTION_FINDOUTPUT	1006
; 32.185   0  #define ACTION_END		1007
; 32.186   0  #define ACTION_SET_FILE_SIZE	1022	/* fast file system only in 1.3 */
; 32.187   0  #define ACTION_WRITE_PROTECT	1023	/* fast file system only in 1.3 */
; 32.188
; 32.189      /* new 2.0 packets */
; 32.190   0  #define ACTION_SAME_LOCK	40
; 32.191   0  #define ACTION_CHANGE_SIGNAL	995
; 32.192   0  #define ACTION_FORMAT		1020
; 32.193   0  #define ACTION_MAKE_LINK	1021
; 32.194      /**/
; 32.195      /**/
; 32.196   0  #define ACTION_READ_LINK	1024
; 32.197   0  #define ACTION_FH_FROM_LOCK	1026
; 32.198   0  #define ACTION_IS_FILESYSTEM	1027
; 32.199   0  #define ACTION_CHANGE_MODE	1028
; 32.200      /**/
; 32.201   0  #define ACTION_COPY_DIR_FH	1030
; 32.202   0  #define ACTION_PARENT_FH	1031
; 32.203   0  #define ACTION_EXAMINE_ALL	1033
; 32.204   0  #define ACTION_EXAMINE_FH	1034
; 32.205
; 32.206   0  #define ACTION_LOCK_RECORD	2008
; 32.207   0  #define ACTION_FREE_RECORD	2009
; 32.208
; 32.209   0  #define ACTION_ADD_NOTIFY	4097
; 32.210   0  #define ACTION_REMOVE_NOTIFY	4098
; 32.211
; 32.212      /* Added in V39: */
; 32.213   0  #define ACTION_EXAMINE_ALL_END	1035
; 32.214   0  #define ACTION_SET_OWNER	1036
; 32.215
; 32.216      /* Tell a file system to serialize the current volume. This is typically
; 32.217       * done by changing the creation date of the disk. This packet does not take
; 32.218       * any arguments.  NOTE: be prepared to handle failure of this packet for
; 32.219       * V37 ROM filesystems.
; 32.220       */
; 32.221   0  #define	ACTION_SERIALIZE_DISK	4200
; 32.222

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 63
;
;
;Line#  Block                                  Source
; 32.223      /*
; 32.224       * A structure for holding error messages - stored as array with error == 0
; 32.225       * for the last entry.
; 32.226       */
; 32.227   0  struct ErrorString {
; 32.228   0  	LONG  *estr_Nums;
; 32.229   0  	UBYTE *estr_Strings;
; 32.230   0  };
; 32.231
; 32.232      /* DOS library node structure.
; 32.233       * This is the data at positive offsets from the library node.
; 32.234       * Negative offsets from the node is the jump table to DOS functions
; 32.235       * node = (struct DosLibrary *) OpenLibrary( "dos.library" .. )	     */
; 32.236
; 32.237   0  struct DosLibrary {
; 32.238   0      struct Library dl_lib;
; 32.239   0      struct RootNode *dl_Root; /* Pointer to RootNode, described below */
; 32.240   0      APTR    dl_GV;	      /* Pointer to BCPL global vector	      */
; 32.241   0      LONG    dl_A2;	      /* BCPL standard register values	      */
; 32.242   0      LONG    dl_A5;
; 32.243   0      LONG    dl_A6;
; 32.244   0      struct ErrorString *dl_Errors;	  /* PRIVATE pointer to array of error msgs *
;       ..... /
; 32.245   0      struct timerequest *dl_TimeReq;	  /* PRIVATE pointer to timer request */
; 32.246   0      struct Library     *dl_UtilityBase;   /* PRIVATE ptr to utility library */
; 32.247   0      struct Library     *dl_IntuitionBase; /* PRIVATE ptr to intuition library */
; 32.248   0  };  /*	DosLibrary */
; 32.249
; 32.250      /*			       */
; 32.251
; 32.252   0  struct RootNode {
; 32.253   0      BPTR    rn_TaskArray;	     /* [0] is max number of CLI's
; 32.254   0  				      * [1] is APTR to process id of CLI 1
; 32.255   0  				      * [n] is APTR to process id of CLI n */
; 32.256   0      BPTR    rn_ConsoleSegment; /* SegList for the CLI			   */
; 32.257   0      struct  DateStamp rn_Time; /* Current time				   */
; 32.258   0      LONG    rn_RestartSeg;     /* SegList for the disk validator process   */
; 32.259   0      BPTR    rn_Info;	       /* Pointer to the Info structure		   */
; 32.260   0      BPTR    rn_FileHandlerSegment; /* segment for a file handler	   */
; 32.261   0      struct MinList rn_CliList; /* new list of all CLI processes */
; 32.262      			       /* the first cpl_Array is also rn_TaskArray */
; 32.263   0      struct MsgPort *rn_BootProc; /* private ptr to msgport of boot fs	   */
; 32.264   0      BPTR    rn_ShellSegment;   /* seglist for Shell (for NewShell)	   */
; 32.265   0      LONG    rn_Flags;	       /* dos flags */
; 32.266   0  };  /* RootNode */
; 32.267
; 32.268   0  #define RNB_WILDSTAR	24
; 32.269   0  #define RNF_WILDSTAR	(1L<<24)
; 32.270   0  #define RNB_PRIVATE1	1	/* private for dos */
; 32.271   0  #define RNF_PRIVATE1	2

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 64
;
;
;Line#  Block                                  Source
; 32.272
; 32.273      /* ONLY to be allocated by DOS! */
; 32.274   0  struct CliProcList {
; 32.275   0  	struct MinNode cpl_Node;
; 32.276   0  	LONG cpl_First;	     /* number of first entry in array */
; 32.277   0  	struct MsgPort **cpl_Array;
; 32.278      			     /* [0] is max number of CLI's in this entry (n)
; 32.279      			      * [1] is CPTR to process id of CLI cpl_First
; 32.280      			      * [n] is CPTR to process id of CLI cpl_First+n-1
; 32.281      			      */
; 32.282   0  };
; 32.283
; 32.284   0  struct DosInfo {
; 32.285   0      BPTR    di_McName;	       /* PRIVATE: system resident module list	    */
; 32.286   0  #define di_ResList di_McName
; 32.287   0      BPTR    di_DevInfo;	       /* Device List				    */
; 32.288   0      BPTR    di_Devices;	       /* Currently zero			    */
; 32.289   0      BPTR    di_Handlers;       /* Currently zero			    */
; 32.290   0      APTR    di_NetHand;	       /* Network handler processid; currently zero */
; 32.291   0      struct  SignalSemaphore di_DevLock;	   /* do NOT access directly! */
; 32.292   0      struct  SignalSemaphore di_EntryLock;  /* do NOT access directly! */
; 32.293   0      struct  SignalSemaphore di_DeleteLock; /* do NOT access directly! */
; 32.294   0  };  /* DosInfo */
; 32.295
; 32.296      /* structure for the Dos resident list.  Do NOT allocate these, use	  */
; 32.297      /* AddSegment(), and heed the warnings in the autodocs!			  */
; 32.298
; 32.299   0  struct Segment {
; 32.300   0  	BPTR seg_Next;
; 32.301   0  	LONG seg_UC;
; 32.302   0  	BPTR seg_Seg;
; 32.303   0  	UBYTE seg_Name[4];	/* actually the first 4 chars of BSTR name */
; 32.304   0  };
; 32.305
; 32.306   0  #define CMD_SYSTEM	-1
; 32.307   0  #define CMD_INTERNAL	-2
; 32.308   0  #define CMD_DISABLED	-999
; 32.309
; 32.310
; 32.311      /* DOS Processes started from the CLI via RUN or NEWCLI have this additional
; 32.312       * set to data associated with them */
; 32.313
; 32.314   0  struct CommandLineInterface {
; 32.315   0      LONG   cli_Result2;	       /* Value of IoErr from last command	  */
; 32.316   0      BSTR   cli_SetName;	       /* Name of current directory		  */
; 32.317   0      BPTR   cli_CommandDir;     /* Head of the path locklist		  */
; 32.318   0      LONG   cli_ReturnCode;     /* Return code from last command		  */
; 32.319   0      BSTR   cli_CommandName;    /* Name of current command		  */
; 32.320   0      LONG   cli_FailLevel;      /* Fail level (set by FAILAT)		  */
; 32.321   0      BSTR   cli_Prompt;	       /* Current prompt (set by PROMPT)	  */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 65
;
;
;Line#  Block                                  Source
; 32.322   0      BPTR   cli_StandardInput;  /* Default (terminal) CLI input		  */
; 32.323   0      BPTR   cli_CurrentInput;   /* Current CLI input			  */
; 32.324   0      BSTR   cli_CommandFile;    /* Name of EXECUTE command file		  */
; 32.325   0      LONG   cli_Interactive;    /* Boolean; True if prompts required	  */
; 32.326   0      LONG   cli_Background;     /* Boolean; True if CLI created by RUN	  */
; 32.327   0      BPTR   cli_CurrentOutput;  /* Current CLI output			  */
; 32.328   0      LONG   cli_DefaultStack;   /* Stack size to be obtained in long words */
; 32.329   0      BPTR   cli_StandardOutput; /* Default (terminal) CLI output		  */
; 32.330   0      BPTR   cli_Module;	       /* SegList of currently loaded command	  */
; 32.331   0  };  /* CommandLineInterface */
; 32.332
; 32.333      /* This structure can take on different values depending on whether it is
; 32.334       * a device, an assigned directory, or a volume.  Below is the structure
; 32.335       * reflecting volumes only.  Following that is the structure representing
; 32.336       * only devices. Following that is the unioned structure representing all
; 32.337       * the values
; 32.338       */
; 32.339
; 32.340      /* structure representing a volume */
; 32.341
; 32.342   0  struct DeviceList {
; 32.343   0      BPTR		dl_Next;	/* bptr to next device list */
; 32.344   0      LONG		dl_Type;	/* see DLT below */
; 32.345   0      struct MsgPort *	dl_Task;	/* ptr to handler task */
; 32.346   0      BPTR		dl_Lock;	/* not for volumes */
; 32.347   0      struct DateStamp	dl_VolumeDate;	/* creation date */
; 32.348   0      BPTR		dl_LockList;	/* outstanding locks */
; 32.349   0      LONG		dl_DiskType;	/* 'DOS', etc */
; 32.350   0      LONG		dl_unused;
; 32.351   0      BSTR		dl_Name;	/* bptr to bcpl name */
; 32.352   0  };
; 32.353
; 32.354      /* device structure (same as the DeviceNode structure in filehandler.h) */
; 32.355
; 32.356   0  struct	      DevInfo {
; 32.357   0      BPTR  dvi_Next;
; 32.358   0      LONG  dvi_Type;
; 32.359   0      APTR  dvi_Task;
; 32.360   0      BPTR  dvi_Lock;
; 32.361   0      BSTR  dvi_Handler;
; 32.362   0      LONG  dvi_StackSize;
; 32.363   0      LONG  dvi_Priority;
; 32.364   0      LONG  dvi_Startup;
; 32.365   0      BPTR  dvi_SegList;
; 32.366   0      BPTR  dvi_GlobVec;
; 32.367   0      BSTR  dvi_Name;
; 32.368   0  };
; 32.369
; 32.370      /* combined structure for devices, assigned directories, volumes */
; 32.371

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 66
;
;
;Line#  Block                                  Source
; 32.372   0  struct DosList {
; 32.373   0      BPTR		dol_Next;	 /* bptr to next device on list */
; 32.374   0      LONG		dol_Type;	 /* see DLT below */
; 32.375   0      struct MsgPort     *dol_Task;	 /* ptr to handler task */
; 32.376   0      BPTR		dol_Lock;
; 32.377   0      union {
; 32.378   0  	struct {
; 32.379   0  	BSTR	dol_Handler;	/* file name to load if seglist is null */
; 32.380   0  	LONG	dol_StackSize;	/* stacksize to use when starting process */
; 32.381   0  	LONG	dol_Priority;	/* task priority when starting process */
; 32.382   0  	ULONG	dol_Startup;	/* startup msg: FileSysStartupMsg for disks */
; 32.383   0  	BPTR	dol_SegList;	/* already loaded code for new task */
; 32.384   0  	BPTR	dol_GlobVec;	/* BCPL global vector to use when starting
; 32.385   0  				 * a process. -1 indicates a C/Assembler
; 32.386   0  				 * program. */
; 32.387   0  	} dol_handler;
; 32.388
; 32.389   0  	struct {
; 32.390   0  	struct DateStamp	dol_VolumeDate;	 /* creation date */
; 32.391   0  	BPTR			dol_LockList;	 /* outstanding locks */
; 32.392   0  	LONG			dol_DiskType;	 /* 'DOS', etc */
; 32.393   0  	} dol_volume;
; 32.394
; 32.395   0  	struct {
; 32.396   0  	UBYTE	*dol_AssignName;     /* name for non-or-late-binding assign */
; 32.397   0  	struct AssignList *dol_List; /* for multi-directory assigns (regular) */
; 32.398   0  	} dol_assign;
; 32.399
; 32.400   0      } dol_misc;
; 32.401
; 32.402   0      BSTR		dol_Name;	 /* bptr to bcpl name */
; 32.403   0      };
; 32.404
; 32.405      /* structure used for multi-directory assigns. AllocVec()ed. */
; 32.406
; 32.407   0  struct AssignList {
; 32.408   0  	struct AssignList *al_Next;
; 32.409   0  	BPTR		   al_Lock;
; 32.410   0  };
; 32.411
; 32.412      /* definitions for dl_Type */
; 32.413   0  #define DLT_DEVICE	0
; 32.414   0  #define DLT_DIRECTORY	1	/* assign */
; 32.415   0  #define DLT_VOLUME	2
; 32.416   0  #define DLT_LATE	3	/* late-binding assign */
; 32.417   0  #define DLT_NONBINDING	4	/* non-binding assign */
; 32.418   0  #define DLT_PRIVATE	-1	/* for internal use only */
; 32.419
; 32.420      /* structure return by GetDeviceProc() */
; 32.421   0  struct DevProc {

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 67
;
;
;Line#  Block                                  Source
; 32.422   0  	struct MsgPort *dvp_Port;
; 32.423   0  	BPTR		dvp_Lock;
; 32.424   0  	ULONG		dvp_Flags;
; 32.425   0  	struct DosList *dvp_DevNode;	/* DON'T TOUCH OR USE! */
; 32.426   0  };
; 32.427
; 32.428      /* definitions for dvp_Flags */
; 32.429   0  #define DVPB_UNLOCK	0
; 32.430   0  #define DVPF_UNLOCK	(1L << DVPB_UNLOCK)
; 32.431   0  #define DVPB_ASSIGN	1
; 32.432   0  #define DVPF_ASSIGN	(1L << DVPB_ASSIGN)
; 32.433
; 32.434      /* Flags to be passed to LockDosList(), etc */
; 32.435   0  #define LDB_DEVICES	2
; 32.436   0  #define LDF_DEVICES	(1L << LDB_DEVICES)
; 32.437   0  #define LDB_VOLUMES	3
; 32.438   0  #define LDF_VOLUMES	(1L << LDB_VOLUMES)
; 32.439   0  #define LDB_ASSIGNS	4
; 32.440   0  #define LDF_ASSIGNS	(1L << LDB_ASSIGNS)
; 32.441   0  #define LDB_ENTRY	5
; 32.442   0  #define LDF_ENTRY	(1L << LDB_ENTRY)
; 32.443   0  #define LDB_DELETE	6
; 32.444   0  #define LDF_DELETE	(1L << LDB_DELETE)
; 32.445
; 32.446      /* you MUST specify one of LDF_READ or LDF_WRITE */
; 32.447   0  #define LDB_READ	0
; 32.448   0  #define LDF_READ	(1L << LDB_READ)
; 32.449   0  #define LDB_WRITE	1
; 32.450   0  #define LDF_WRITE	(1L << LDB_WRITE)
; 32.451
; 32.452      /* actually all but LDF_ENTRY (which is used for internal locking) */
; 32.453   0  #define LDF_ALL		(LDF_DEVICES|LDF_VOLUMES|LDF_ASSIGNS)
; 32.454
; 32.455      /* a lock structure, as returned by Lock() or DupLock() */
; 32.456   0  struct FileLock {
; 32.457   0      BPTR		fl_Link;	/* bcpl pointer to next lock */
; 32.458   0      LONG		fl_Key;		/* disk block number */
; 32.459   0      LONG		fl_Access;	/* exclusive or shared */
; 32.460   0      struct MsgPort *	fl_Task;	/* handler task's port */
; 32.461   0      BPTR		fl_Volume;	/* bptr to DLT_VOLUME DosList entry */
; 32.462   0  };
; 32.463
; 32.464      /* error report types for ErrorReport() */
; 32.465   0  #define REPORT_STREAM		0	/* a stream */
; 32.466   0  #define REPORT_TASK		1	/* a process - unused */
; 32.467   0  #define REPORT_LOCK		2	/* a lock */
; 32.468   0  #define REPORT_VOLUME		3	/* a volume node */
; 32.469   0  #define REPORT_INSERT		4	/* please insert volume */
; 32.470
; 32.471      /* Special error codes for ErrorReport() */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 68
;
;
;Line#  Block                                  Source
; 32.472   0  #define ABORT_DISK_ERROR	296	/* Read/write error */
; 32.473   0  #define ABORT_BUSY		288	/* You MUST replace... */
; 32.474
; 32.475      /* types for initial packets to shells from run/newcli/execute/system. */
; 32.476      /* For shell-writers only */
; 32.477   0  #define RUN_EXECUTE		-1
; 32.478   0  #define RUN_SYSTEM		-2
; 32.479   0  #define RUN_SYSTEM_ASYNCH	-3
; 32.480
; 32.481      /* Types for fib_DirEntryType.	NOTE that both USERDIR and ROOT are	 */
; 32.482      /* directories, and that directory/file checks should use <0 and >=0.	 */
; 32.483      /* This is not necessarily exhaustive!	Some handlers may use other	 */
; 32.484      /* values as needed, though <0 and >=0 should remain as supported as	 */
; 32.485      /* possible.								 */
; 32.486   0  #define ST_ROOT		1
; 32.487   0  #define ST_USERDIR	2
; 32.488   0  #define ST_SOFTLINK	3	/* looks like dir, but may point to a file! */
; 32.489   0  #define ST_LINKDIR	4	/* hard link to dir */
; 32.490   0  #define ST_FILE		-3	/* must be negative for FIB! */
; 32.491   0  #define ST_LINKFILE	-4	/* hard link to file */
; 32.492   0  #define ST_PIPEFILE	-5	/* for pipes that support ExamineFH */
; 32.493
; 32.494   0  #endif	/* DOS_DOSEXTENS_H */
; 30.019   0  #endif
; 30.020   0  #ifndef  DOS_RECORD_H
; 30.021   0  #include <dos/record.h>
;===> Including file "sc:include/dos/record.h"
; 35.001   0  #ifndef DOS_RECORD_H
; 35.002   0  #define DOS_RECORD_H
; 35.003      /*
; 35.004      **
; 35.005      **	$VER: record.h 36.5 (12.7.90)
; 35.006      **	Includes Release 40.13
; 35.007      **
; 35.008      **	include file for record locking
; 35.009      **
; 35.010      **	(C) Copyright 1989-1993 Commodore-Amiga, Inc.
; 35.011      **	    All Rights Reserved
; 35.012      **
; 35.013      */
; 35.014
; 35.015   0  #ifndef DOS_DOS_H
; 35.016      #include "dos/dos.h"
; 35.017      #endif
; 35.018
; 35.019      /* Modes for LockRecord/LockRecords() */
; 35.020   0  #define REC_EXCLUSIVE		0
; 35.021   0  #define REC_EXCLUSIVE_IMMED	1
; 35.022   0  #define REC_SHARED		2
; 35.023   0  #define REC_SHARED_IMMED	3

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 69
;
;
;Line#  Block                                  Source
; 35.024
; 35.025      /* struct to be passed to LockRecords()/UnLockRecords() */
; 35.026
; 35.027   0  struct RecordLock {
; 35.028   0  	BPTR	rec_FH;		/* filehandle */
; 35.029   0  	ULONG	rec_Offset;	/* offset in file */
; 35.030   0  	ULONG	rec_Length;	/* length of file to be locked */
; 35.031   0  	ULONG	rec_Mode;	/* Type of lock */
; 35.032   0  };
; 35.033
; 35.034   0  #endif /* DOS_RECORD_H */
; 30.022   0  #endif
; 30.023   0  #ifndef  DOS_RDARGS_H
; 30.024   0  #include <dos/rdargs.h>
;===> Including file "sc:include/dos/rdargs.h"
; 36.001   0  #ifndef DOS_RDARGS_H
; 36.002   0  #define DOS_RDARGS_H
; 36.003      /*
; 36.004      **
; 36.005      **	$VER: rdargs.h 36.6 (12.7.90)
; 36.006      **	Includes Release 40.13
; 36.007      **
; 36.008      **	ReadArgs() structure definitions
; 36.009      **
; 36.010      **	(C) Copyright 1989-1993 Commodore-Amiga, Inc.
; 36.011      **	    All Rights Reserved
; 36.012      **
; 36.013      */
; 36.014
; 36.015   0  #ifndef EXEC_TYPES_H
; 36.016      #include "exec/types.h"
; 36.017      #endif
; 36.018
; 36.019   0  #ifndef EXEC_NODES_H
; 36.020      #include "exec/nodes.h"
; 36.021      #endif
; 36.022
; 36.023      /**********************************************************************
; 36.024       *
; 36.025       * The CSource data structure defines the input source for "ReadItem()"
; 36.026       * as well as the ReadArgs call.  It is a publicly defined structure
; 36.027       * which may be used by applications which use code that follows the
; 36.028       * conventions defined for access.
; 36.029       *
; 36.030       * When passed to the dos.library functions, the value passed as
; 36.031       * struct *CSource is defined as follows:
; 36.032       *	if ( CSource == 0)	Use buffered IO "ReadChar()" as data source
; 36.033       *	else			Use CSource for input character stream
; 36.034       *
; 36.035       * The following two pseudo-code routines define how the CSource structure

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 70
;
;
;Line#  Block                                  Source
; 36.036       * is used:
; 36.037       *
; 36.038       * long CS_ReadChar( struct CSource *CSource )
; 36.039       * {
; 36.040       *	if ( CSource == 0 )	return ReadChar();
; 36.041       *	if ( CSource->CurChr >= CSource->Length )	return ENDSTREAMCHAR;
; 36.042       *	return CSource->Buffer[ CSource->CurChr++ ];
; 36.043       * }
; 36.044       *
; 36.045       * BOOL CS_UnReadChar( struct CSource *CSource )
; 36.046       * {
; 36.047       *	if ( CSource == 0 )	return UnReadChar();
; 36.048       *	if ( CSource->CurChr <= 0 )	return FALSE;
; 36.049       *	CSource->CurChr--;
; 36.050       *	return TRUE;
; 36.051       * }
; 36.052       *
; 36.053       * To initialize a struct CSource, you set CSource->CS_Buffer to
; 36.054       * a string which is used as the data source, and set CS_Length to
; 36.055       * the number of characters in the string.  Normally CS_CurChr should
; 36.056       * be initialized to ZERO, or left as it was from prior use as
; 36.057       * a CSource.
; 36.058       *
; 36.059       **********************************************************************/
; 36.060
; 36.061   0  struct CSource {
; 36.062   0  	UBYTE	*CS_Buffer;
; 36.063   0  	LONG	CS_Length;
; 36.064   0  	LONG	CS_CurChr;
; 36.065   0  };
; 36.066
; 36.067      /**********************************************************************
; 36.068       *
; 36.069       * The RDArgs data structure is the input parameter passed to the DOS
; 36.070       * ReadArgs() function call.
; 36.071       *
; 36.072       * The RDA_Source structure is a CSource as defined above;
; 36.073       * if RDA_Source.CS_Buffer is non-null, RDA_Source is used as the input
; 36.074       * character stream to parse, else the input comes from the buffered STDIN
; 36.075       * calls ReadChar/UnReadChar.
; 36.076       *
; 36.077       * RDA_DAList is a private address which is used internally to track
; 36.078       * allocations which are freed by FreeArgs().  This MUST be initialized
; 36.079       * to NULL prior to the first call to ReadArgs().
; 36.080       *
; 36.081       * The RDA_Buffer and RDA_BufSiz fields allow the application to supply
; 36.082       * a fixed-size buffer in which to store the parsed data.  This allows
; 36.083       * the application to pre-allocate a buffer rather than requiring buffer
; 36.084       * space to be allocated.  If either RDA_Buffer or RDA_BufSiz is NULL,
; 36.085       * the application has not supplied a buffer.

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 71
;
;
;Line#  Block                                  Source
; 36.086       *
; 36.087       * RDA_ExtHelp is a text string which will be displayed instead of the
; 36.088       * template string, if the user is prompted for input.
; 36.089       *
; 36.090       * RDA_Flags bits control how ReadArgs() works.  The flag bits are
; 36.091       * defined below.  Defaults are initialized to ZERO.
; 36.092       *
; 36.093       **********************************************************************/
; 36.094
; 36.095   0  struct RDArgs {
; 36.096   0  	struct	CSource RDA_Source;	/* Select input source */
; 36.097   0  	LONG	RDA_DAList;		/* PRIVATE. */
; 36.098   0  	UBYTE	*RDA_Buffer;		/* Optional string parsing space. */
; 36.099   0  	LONG	RDA_BufSiz;		/* Size of RDA_Buffer (0..n) */
; 36.100   0  	UBYTE	*RDA_ExtHelp;		/* Optional extended help */
; 36.101   0  	LONG	RDA_Flags;		/* Flags for any required control */
; 36.102   0  };
; 36.103
; 36.104   0  #define RDAB_STDIN	0	/* Use "STDIN" rather than "COMMAND LINE" */
; 36.105   0  #define RDAF_STDIN	1
; 36.106   0  #define RDAB_NOALLOC	1	/* If set, do not allocate extra string space.*/
; 36.107   0  #define RDAF_NOALLOC	2
; 36.108   0  #define RDAB_NOPROMPT	2	/* Disable reprompting for string input. */
; 36.109   0  #define RDAF_NOPROMPT	4
; 36.110
; 36.111      /**********************************************************************
; 36.112       * Maximum number of template keywords which can be in a template passed
; 36.113       * to ReadArgs(). IMPLEMENTOR NOTE - must be a multiple of 4.
; 36.114       **********************************************************************/
; 36.115   0  #define MAX_TEMPLATE_ITEMS	100
; 36.116
; 36.117      /**********************************************************************
; 36.118       * Maximum number of MULTIARG items returned by ReadArgs(), before
; 36.119       * an ERROR_LINE_TOO_LONG.  These two limitations are due to stack
; 36.120       * usage.  Applications should allow "a lot" of stack to use ReadArgs().
; 36.121       **********************************************************************/
; 36.122   0  #define MAX_MULTIARGS		128
; 36.123
; 36.124   0  #endif /* DOS_RDARGS_H */
; 30.025   0  #endif
; 30.026   0  #ifndef  DOS_DOSASL_H
; 30.027   0  #include <dos/dosasl.h>
;===> Including file "sc:include/dos/dosasl.h"
; 37.001   0  #ifndef DOS_DOSASL_H
; 37.002   0  #define DOS_DOSASL_H
; 37.003      /*
; 37.004      **
; 37.005      **	$VER: dosasl.h 36.16 (2.5.91)
; 37.006      **	Includes Release 40.13
; 37.007      **

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 72
;
;
;Line#  Block                                  Source
; 37.008      **	Pattern-matching structure definitions
; 37.009      **
; 37.010      **	(C) Copyright 1989-1993 Commodore-Amiga, Inc.
; 37.011      **	    All Rights Reserved
; 37.012      **
; 37.013      */
; 37.014
; 37.015   0  #ifndef EXEC_LIBRARIES_H
; 37.016      #include <exec/libraries.h>
; 37.017      #endif
; 37.018
; 37.019   0  #ifndef EXEC_LISTS_H
; 37.020      #include <exec/lists.h>
; 37.021      #endif
; 37.022
; 37.023   0  #ifndef DOS_DOS_H
; 37.024      #include <dos/dos.h>
; 37.025      #endif
; 37.026
; 37.027
; 37.028      /***********************************************************************
; 37.029      ************************ PATTERN MATCHING ******************************
; 37.030      ************************************************************************
; 37.031
; 37.032      * structure expected by MatchFirst, MatchNext.
; 37.033      * Allocate this structure and initialize it as follows:
; 37.034      *
; 37.035      * Set ap_BreakBits to the signal bits (CDEF) that you want to take a
; 37.036      * break on, or NULL, if you don't want to convenience the user.
; 37.037      *
; 37.038      * If you want to have the FULL PATH NAME of the files you found,
; 37.039      * allocate a buffer at the END of this structure, and put the size of
; 37.040      * it into ap_Strlen.  If you don't want the full path name, make sure
; 37.041      * you set ap_Strlen to zero.  In this case, the name of the file, and stats
; 37.042      * are available in the ap_Info, as per usual.
; 37.043      *
; 37.044      * Then call MatchFirst() and then afterwards, MatchNext() with this structure.
; 37.045      * You should check the return value each time (see below) and take the
; 37.046      * appropriate action, ultimately calling MatchEnd() when there are
; 37.047      * no more files and you are done.  You can tell when you are done by
; 37.048      * checking for the normal AmigaDOS return code ERROR_NO_MORE_ENTRIES.
; 37.049      *
; 37.050      */
; 37.051
; 37.052   0  struct AnchorPath {
; 37.053   0  	struct AChain	*ap_Base;	/* pointer to first anchor */
; 37.054   0  #define	ap_First ap_Base
; 37.055   0  	struct AChain	*ap_Last;	/* pointer to last anchor */
; 37.056   0  #define ap_Current ap_Last
; 37.057   0  	LONG	ap_BreakBits;	/* Bits we want to break on */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 73
;
;
;Line#  Block                                  Source
; 37.058   0  	LONG	ap_FoundBreak;	/* Bits we broke on. Also returns ERROR_BREAK */
; 37.059   0  	BYTE	ap_Flags;	/* New use for extra word. */
; 37.060   0  	BYTE	ap_Reserved;
; 37.061   0  	WORD	ap_Strlen;	/* This is what ap_Length used to be */
; 37.062   0  #define	ap_Length ap_Flags	/* Old compatability for LONGWORD ap_Length */
; 37.063   0  	struct	FileInfoBlock ap_Info;
; 37.064   0  	UBYTE	ap_Buf[1];	/* Buffer for path name, allocated by user */
; 37.065      	/* FIX! */
; 37.066   0  };
; 37.067
; 37.068
; 37.069   0  #define	APB_DOWILD	0	/* User option ALL */
; 37.070   0  #define APF_DOWILD	1
; 37.071
; 37.072   0  #define	APB_ITSWILD	1	/* Set by MatchFirst, used by MatchNext	 */
; 37.073   0  #define APF_ITSWILD	2	/* Application can test APB_ITSWILD, too */
; 37.074      				/* (means that there's a wildcard	 */
; 37.075      				/* in the pattern after calling		 */
; 37.076      				/* MatchFirst).				 */
; 37.077
; 37.078   0  #define	APB_DODIR	2	/* Bit is SET if a DIR node should be */
; 37.079   0  #define APF_DODIR	4	/* entered. Application can RESET this */
; 37.080      				/* bit after MatchFirst/MatchNext to AVOID */
; 37.081      				/* entering a dir. */
; 37.082
; 37.083   0  #define	APB_DIDDIR	3	/* Bit is SET for an "expired" dir node. */
; 37.084   0  #define APF_DIDDIR	8
; 37.085
; 37.086   0  #define	APB_NOMEMERR	4	/* Set on memory error */
; 37.087   0  #define APF_NOMEMERR	16
; 37.088
; 37.089   0  #define	APB_DODOT	5	/* If set, allow conversion of '.' to */
; 37.090   0  #define APF_DODOT	32	/* CurrentDir */
; 37.091
; 37.092   0  #define APB_DirChanged	6	/* ap_Current->an_Lock changed */
; 37.093   0  #define APF_DirChanged	64	/* since last MatchNext call */
; 37.094
; 37.095   0  #define APB_FollowHLinks 7	/* follow hardlinks on DODIR - defaults   */
; 37.096   0  #define APF_FollowHLinks 128	/* to not following hardlinks on a DODIR. */
; 37.097
; 37.098
; 37.099   0  struct AChain {
; 37.100   0  	struct AChain *an_Child;
; 37.101   0  	struct AChain *an_Parent;
; 37.102   0  	BPTR	an_Lock;
; 37.103   0  	struct FileInfoBlock an_Info;
; 37.104   0  	BYTE	an_Flags;
; 37.105   0  	UBYTE	an_String[1];	/* FIX!! */
; 37.106   0  };
; 37.107

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 74
;
;
;Line#  Block                                  Source
; 37.108   0  #define	DDB_PatternBit	0
; 37.109   0  #define	DDF_PatternBit	1
; 37.110   0  #define	DDB_ExaminedBit	1
; 37.111   0  #define	DDF_ExaminedBit	2
; 37.112   0  #define	DDB_Completed	2
; 37.113   0  #define	DDF_Completed	4
; 37.114   0  #define	DDB_AllBit	3
; 37.115   0  #define	DDF_AllBit	8
; 37.116   0  #define	DDB_Single	4
; 37.117   0  #define	DDF_Single	16
; 37.118
; 37.119      /*
; 37.120       * Constants used by wildcard routines, these are the pre-parsed tokens
; 37.121       * referred to by pattern match.  It is not necessary for you to do
; 37.122       * anything about these, MatchFirst() MatchNext() handle all these for you.
; 37.123       */
; 37.124
; 37.125   0  #define P_ANY		0x80	/* Token for '*' or '#?  */
; 37.126   0  #define P_SINGLE	0x81	/* Token for '?' */
; 37.127   0  #define P_ORSTART	0x82	/* Token for '(' */
; 37.128   0  #define P_ORNEXT	0x83	/* Token for '|' */
; 37.129   0  #define P_OREND	0x84	/* Token for ')' */
; 37.130   0  #define P_NOT		0x85	/* Token for '~' */
; 37.131   0  #define P_NOTEND	0x86	/* Token for */
; 37.132   0  #define P_NOTCLASS	0x87	/* Token for '^' */
; 37.133   0  #define P_CLASS	0x88	/* Token for '[]' */
; 37.134   0  #define P_REPBEG	0x89	/* Token for '[' */
; 37.135   0  #define P_REPEND	0x8A	/* Token for ']' */
; 37.136   0  #define P_STOP		0x8B	/* token to force end of evaluation */
; 37.137
; 37.138      /* Values for an_Status, NOTE: These are the actual bit numbers */
; 37.139
; 37.140   0  #define COMPLEX_BIT	1	/* Parsing complex pattern */
; 37.141   0  #define EXAMINE_BIT	2	/* Searching directory */
; 37.142
; 37.143      /*
; 37.144       * Returns from MatchFirst(), MatchNext()
; 37.145       * You can also get dos error returns, such as ERROR_NO_MORE_ENTRIES,
; 37.146       * these are in the dos.h file.
; 37.147       */
; 37.148
; 37.149   0  #define ERROR_BUFFER_OVERFLOW	303	/* User or internal buffer overflow */
; 37.150   0  #define ERROR_BREAK		304	/* A break character was received */
; 37.151   0  #define ERROR_NOT_EXECUTABLE	305	/* A file has E bit cleared */
; 37.152
; 37.153   0  #endif /* DOS_DOSASL_H */
; 30.028   0  #endif
; 30.029   0  #ifndef  DOS_VAR_H
; 30.030   0  #include <dos/var.h>
;===> Including file "sc:include/dos/var.h"

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 75
;
;
;Line#  Block                                  Source
; 38.001   0  #ifndef DOS_VAR_H
; 38.002   0  #define DOS_VAR_H
; 38.003      /*
; 38.004      **
; 38.005      **	$VER: var.h 36.11 (2.6.92)
; 38.006      **	Includes Release 40.13
; 38.007      **
; 38.008      **	include file for dos local and environment variables
; 38.009      **
; 38.010      **	(C) Copyright 1989-1993 Commodore-Amiga, Inc.
; 38.011      **	    All Rights Reserved
; 38.012      **
; 38.013      */
; 38.014
; 38.015
; 38.016   0  #ifndef EXEC_NODES_H
; 38.017      #include "exec/nodes.h"
; 38.018      #endif
; 38.019
; 38.020      /* the structure in the pr_LocalVars list */
; 38.021      /* Do NOT allocate yourself, use SetVar()!!! This structure may grow in */
; 38.022      /* future releases!  The list should be left in alphabetical order, and */
; 38.023      /* may have multiple entries with the same name but different types.	*/
; 38.024
; 38.025   0  struct LocalVar {
; 38.026   0  	struct Node lv_Node;
; 38.027   0  	UWORD	lv_Flags;
; 38.028   0  	UBYTE	*lv_Value;
; 38.029   0  	ULONG	lv_Len;
; 38.030   0  };
; 38.031
; 38.032      /*
; 38.033       * The lv_Flags bits are available to the application.	The unused
; 38.034       * lv_Node.ln_Pri bits are reserved for system use.
; 38.035       */
; 38.036
; 38.037      /* bit definitions for lv_Node.ln_Type: */
; 38.038   0  #define LV_VAR			0	/* an variable */
; 38.039   0  #define LV_ALIAS		1	/* an alias */
; 38.040      /* to be or'ed into type: */
; 38.041   0  #define LVB_IGNORE		7	/* ignore this entry on GetVar, etc */
; 38.042   0  #define LVF_IGNORE		0x80
; 38.043
; 38.044      /* definitions of flags passed to GetVar()/SetVar()/DeleteVar() */
; 38.045      /* bit defs to be OR'ed with the type: */
; 38.046      /* item will be treated as a single line of text unless BINARY_VAR is used */
; 38.047   0  #define GVB_GLOBAL_ONLY		8
; 38.048   0  #define GVF_GLOBAL_ONLY		0x100
; 38.049   0  #define GVB_LOCAL_ONLY		9
; 38.050   0  #define GVF_LOCAL_ONLY		0x200

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 76
;
;
;Line#  Block                                  Source
; 38.051   0  #define GVB_BINARY_VAR		10		/* treat variable as binary */
; 38.052   0  #define GVF_BINARY_VAR		0x400
; 38.053   0  #define GVB_DONT_NULL_TERM	11	/* only with GVF_BINARY_VAR */
; 38.054   0  #define GVF_DONT_NULL_TERM	0x800
; 38.055
; 38.056      /* this is only supported in >= V39 dos.  V37 dos ignores this. */
; 38.057      /* this causes SetVar to affect ENVARC: as well as ENV:.	*/
; 38.058   0  #define GVB_SAVE_VAR		12	/* only with GVF_GLOBAL_VAR */
; 38.059   0  #define GVF_SAVE_VAR		0x1000
; 38.060
; 38.061   0  #endif /* DOS_VAR_H */
; 30.031   0  #endif
; 30.032   0  #ifndef  DOS_NOTIFY_H
; 30.033   0  #include <dos/notify.h>
;===> Including file "sc:include/dos/notify.h"
; 39.001   0  #ifndef DOS_NOTIFY_H
; 39.002   0  #define DOS_NOTIFY_H
; 39.003      /*
; 39.004      **
; 39.005      **	$VER: notify.h 36.8 (29.8.90)
; 39.006      **	Includes Release 40.13
; 39.007      **
; 39.008      **	dos notification definitions
; 39.009      **
; 39.010      **	(C) Copyright 1989-1993 Commodore-Amiga, Inc.
; 39.011      **	    All Rights Reserved
; 39.012      **
; 39.013      */
; 39.014
; 39.015   0  #ifndef EXEC_TYPES_H
; 39.016      #include "exec/types.h"
; 39.017      #endif
; 39.018
; 39.019   0  #ifndef EXEC_PORTS_H
; 39.020      #include "exec/ports.h"
; 39.021      #endif
; 39.022
; 39.023   0  #ifndef EXEC_TASKS_H
; 39.024      #include "exec/tasks.h"
; 39.025      #endif
; 39.026
; 39.027
; 39.028      /* use of Class and code is discouraged for the time being - we might want to
; 39.029         change things */
; 39.030      /* --- NotifyMessage Class ------------------------------------------------ */
; 39.031   0  #define NOTIFY_CLASS	0x40000000
; 39.032
; 39.033      /* --- NotifyMessage Codes ------------------------------------------------ */
; 39.034   0  #define NOTIFY_CODE	0x1234
; 39.035

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 77
;
;
;Line#  Block                                  Source
; 39.036
; 39.037      /* Sent to the application if SEND_MESSAGE is specified.		    */
; 39.038
; 39.039   0  struct NotifyMessage {
; 39.040   0      struct Message nm_ExecMessage;
; 39.041   0      ULONG  nm_Class;
; 39.042   0      UWORD  nm_Code;
; 39.043   0      struct NotifyRequest *nm_NReq;	/* don't modify the request! */
; 39.044   0      ULONG  nm_DoNotTouch;		/* like it says!  For use by handlers */
; 39.045   0      ULONG  nm_DoNotTouch2;		/* ditto */
; 39.046   0  };
; 39.047
; 39.048      /* Do not modify or reuse the notifyrequest while active.		    */
; 39.049      /* note: the first LONG of nr_Data has the length transfered		    */
; 39.050
; 39.051   0  struct NotifyRequest {
; 39.052   0  	UBYTE *nr_Name;
; 39.053   0  	UBYTE *nr_FullName;		/* set by dos - don't touch */
; 39.054   0  	ULONG nr_UserData;		/* for applications use */
; 39.055   0  	ULONG nr_Flags;
; 39.056
; 39.057   0  	union {
; 39.058
; 39.059   0  	    struct {
; 39.060   0  		struct MsgPort *nr_Port;	/* for SEND_MESSAGE */
; 39.061   0  	    } nr_Msg;
; 39.062
; 39.063   0  	    struct {
; 39.064   0  		struct Task *nr_Task;		/* for SEND_SIGNAL */
; 39.065   0  		UBYTE nr_SignalNum;		/* for SEND_SIGNAL */
; 39.066   0  		UBYTE nr_pad[3];
; 39.067   0  	    } nr_Signal;
; 39.068   0  	} nr_stuff;
; 39.069
; 39.070   0  	ULONG nr_Reserved[4];		/* leave 0 for now */
; 39.071
; 39.072      	/* internal use by handlers */
; 39.073   0  	ULONG nr_MsgCount;		/* # of outstanding msgs */
; 39.074   0  	struct MsgPort *nr_Handler;	/* handler sent to (for EndNotify) */
; 39.075   0  };
; 39.076
; 39.077      /* --- NotifyRequest Flags ------------------------------------------------ */
; 39.078   0  #define NRF_SEND_MESSAGE	1
; 39.079   0  #define NRF_SEND_SIGNAL		2
; 39.080   0  #define NRF_WAIT_REPLY		8
; 39.081   0  #define NRF_NOTIFY_INITIAL	16
; 39.082
; 39.083      /* do NOT set or remove NRF_MAGIC!  Only for use by handlers! */
; 39.084   0  #define NRF_MAGIC	0x80000000
; 39.085

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 78
;
;
;Line#  Block                                  Source
; 39.086      /* bit numbers */
; 39.087   0  #define NRB_SEND_MESSAGE	0
; 39.088   0  #define NRB_SEND_SIGNAL		1
; 39.089   0  #define NRB_WAIT_REPLY		3
; 39.090   0  #define NRB_NOTIFY_INITIAL	4
; 39.091
; 39.092   0  #define NRB_MAGIC		31
; 39.093
; 39.094      /* Flags reserved for private use by the handler: */
; 39.095   0  #define NR_HANDLER_FLAGS	0xffff0000
; 39.096
; 39.097   0  #endif /* DOS_NOTIFY_H */
; 30.034   0  #endif
; 30.035   0  #ifndef  DOS_DATETIME_H
; 30.036   0  #include <dos/datetime.h>
;===> Including file "sc:include/dos/datetime.h"
; 40.001   0  #ifndef DOS_DATETIME_H
; 40.002   0  #define DOS_DATETIME_H
; 40.003
; 40.004      /*
; 40.005      **	$VER: datetime.h 36.7 (12.7.90)
; 40.006      **	Includes Release 40.13
; 40.007      **
; 40.008      **	Date and time C header for AmigaDOS
; 40.009      **
; 40.010      **	(C) Copyright 1989-1993 Commodore-Amiga, Inc.
; 40.011      **	    All Rights Reserved
; 40.012      **
; 40.013      */
; 40.014
; 40.015   0  #ifndef DOS_DOS_H
; 40.016      #include "dos/dos.h"
; 40.017      #endif
; 40.018
; 40.019      /*
; 40.020       *	Data structures and equates used by the V1.4 DOS functions
; 40.021       * StrtoDate() and DatetoStr()
; 40.022       */
; 40.023
; 40.024      /*--------- String/Date structures etc */
; 40.025   0  struct DateTime {
; 40.026   0  	struct DateStamp dat_Stamp;	/* DOS DateStamp */
; 40.027   0  	UBYTE	dat_Format;		/* controls appearance of dat_StrDate */
; 40.028   0  	UBYTE	dat_Flags;		/* see BITDEF's below */
; 40.029   0  	UBYTE	*dat_StrDay;		/* day of the week string */
; 40.030   0  	UBYTE	*dat_StrDate;		/* date string */
; 40.031   0  	UBYTE	*dat_StrTime;		/* time string */
; 40.032   0  };
; 40.033
; 40.034      /* You need this much room for each of the DateTime strings: */

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 79
;
;
;Line#  Block                                  Source
; 40.035   0  #define	LEN_DATSTRING	16
; 40.036
; 40.037      /*	flags for dat_Flags */
; 40.038
; 40.039   0  #define DTB_SUBST	0		/* substitute Today, Tomorrow, etc. */
; 40.040   0  #define DTF_SUBST	1
; 40.041   0  #define DTB_FUTURE	1		/* day of the week is in future */
; 40.042   0  #define DTF_FUTURE	2
; 40.043
; 40.044      /*
; 40.045       *	date format values
; 40.046       */
; 40.047
; 40.048   0  #define FORMAT_DOS	0		/* dd-mmm-yy */
; 40.049   0  #define FORMAT_INT	1		/* yy-mm-dd  */
; 40.050   0  #define FORMAT_USA	2		/* mm-dd-yy  */
; 40.051   0  #define FORMAT_CDN	3		/* dd-mm-yy  */
; 40.052   0  #define FORMAT_MAX	FORMAT_CDN
; 40.053
; 40.054   0  #endif /* DOS_DATETIME_H */
; 30.037   0  #endif
; 30.038   0  BPTR Open( STRPTR name, long accessMode );
; 30.039   0  LONG Close( BPTR file );
; 30.040   0  LONG Read( BPTR file, APTR buffer, long length );
; 30.041   0  LONG Write( BPTR file, APTR buffer, long length );
; 30.042   0  BPTR Input( void );
; 30.043   0  BPTR Output( void );
; 30.044   0  LONG Seek( BPTR file, long position, long offset );
; 30.045   0  LONG DeleteFile( STRPTR name );
; 30.046   0  LONG Rename( STRPTR oldName, STRPTR newName );
; 30.047   0  BPTR Lock( STRPTR name, long type );
; 30.048   0  void UnLock( BPTR lock );
; 30.049   0  BPTR DupLock( BPTR lock );
; 30.050   0  LONG Examine( BPTR lock, struct FileInfoBlock *fileInfoBlock );
; 30.051   0  LONG ExNext( BPTR lock, struct FileInfoBlock *fileInfoBlock );
; 30.052   0  LONG Info( BPTR lock, struct InfoData *parameterBlock );
; 30.053   0  BPTR CreateDir( STRPTR name );
; 30.054   0  BPTR CurrentDir( BPTR lock );
; 30.055   0  LONG IoErr( void );
; 30.056   0  struct MsgPort *CreateProc( STRPTR name, long pri, BPTR segList,
; 30.057   0  	long stackSize );
; 30.058   0  void Exit( long returnCode );
; 30.059   0  BPTR LoadSeg( STRPTR name );
; 30.060   0  void UnLoadSeg( BPTR seglist );
; 30.061   0  struct MsgPort *DeviceProc( STRPTR name );
; 30.062   0  LONG SetComment( STRPTR name, STRPTR comment );
; 30.063   0  LONG SetProtection( STRPTR name, long protect );
; 30.064   0  struct DateStamp *DateStamp( struct DateStamp *date );
; 30.065   0  void Delay( long timeout );
; 30.066   0  LONG WaitForChar( BPTR file, long timeout );

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 80
;
;
;Line#  Block                                  Source
; 30.067   0  BPTR ParentDir( BPTR lock );
; 30.068   0  LONG IsInteractive( BPTR file );
; 30.069   0  LONG Execute( STRPTR string, BPTR file, BPTR file2 );
; 30.070      /*--- functions in V36 or higher (Release 2.0) ---*/
; 30.071      /*	DOS Object creation/deletion */
; 30.072   0  APTR AllocDosObject( unsigned long type, struct TagItem *tags );
; 30.073   0  APTR AllocDosObjectTagList( unsigned long type, struct TagItem *tags );
; 30.074   0  APTR AllocDosObjectTags( unsigned long type, unsigned long tag1type, ... );
; 30.075   0  void FreeDosObject( unsigned long type, APTR ptr );
; 30.076      /*	Packet Level routines */
; 30.077   0  LONG DoPkt( struct MsgPort *port, long action, long arg1, long arg2, long arg3,
; 30.078   0  	long arg4, long arg5 );
; 30.079   0  LONG DoPkt0( struct MsgPort *port, long action );
; 30.080   0  LONG DoPkt1( struct MsgPort *port, long action, long arg1 );
; 30.081   0  LONG DoPkt2( struct MsgPort *port, long action, long arg1, long arg2 );
; 30.082   0  LONG DoPkt3( struct MsgPort *port, long action, long arg1, long arg2,
; 30.083   0  	long arg3 );
; 30.084   0  LONG DoPkt4( struct MsgPort *port, long action, long arg1, long arg2,
; 30.085   0  	long arg3, long arg4 );
; 30.086   0  void SendPkt( struct DosPacket *dp, struct MsgPort *port,
; 30.087   0  	struct MsgPort *replyport );
; 30.088   0  struct DosPacket *WaitPkt( void );
; 30.089   0  void ReplyPkt( struct DosPacket *dp, long res1, long res2 );
; 30.090   0  void AbortPkt( struct MsgPort *port, struct DosPacket *pkt );
; 30.091      /*	Record Locking */
; 30.092   0  BOOL LockRecord( BPTR fh, unsigned long offset, unsigned long length,
; 30.093   0  	unsigned long mode, unsigned long timeout );
; 30.094   0  BOOL LockRecords( struct RecordLock *recArray, unsigned long timeout );
; 30.095   0  BOOL UnLockRecord( BPTR fh, unsigned long offset, unsigned long length );
; 30.096   0  BOOL UnLockRecords( struct RecordLock *recArray );
; 30.097      /*	Buffered File I/O */
; 30.098   0  BPTR SelectInput( BPTR fh );
; 30.099   0  BPTR SelectOutput( BPTR fh );
; 30.100   0  LONG FGetC( BPTR fh );
; 30.101   0  LONG FPutC( BPTR fh, long ch );
; 30.102   0  LONG UnGetC( BPTR fh, long character );
; 30.103   0  LONG FRead( BPTR fh, APTR block, unsigned long blocklen,
; 30.104   0  	unsigned long number );
; 30.105   0  LONG FWrite( BPTR fh, APTR block, unsigned long blocklen,
; 30.106   0  	unsigned long number );
; 30.107   0  STRPTR FGets( BPTR fh, STRPTR buf, unsigned long buflen );
; 30.108   0  LONG FPuts( BPTR fh, STRPTR str );
; 30.109   0  void VFWritef( BPTR fh, STRPTR format, LONG *argarray );
; 30.110   0  void FWritef( BPTR fh, STRPTR format, ... );
; 30.111   0  LONG VFPrintf( BPTR fh, STRPTR format, APTR argarray );
; 30.112   0  LONG FPrintf( BPTR fh, STRPTR format, ... );
; 30.113   0  LONG Flush( BPTR fh );
; 30.114   0  LONG SetVBuf( BPTR fh, STRPTR buff, long type, long size );
; 30.115      /*	DOS Object Management */
; 30.116   0  BPTR DupLockFromFH( BPTR fh );

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 81
;
;
;Line#  Block                                  Source
; 30.117   0  BPTR OpenFromLock( BPTR lock );
; 30.118   0  BPTR ParentOfFH( BPTR fh );
; 30.119   0  BOOL ExamineFH( BPTR fh, struct FileInfoBlock *fib );
; 30.120   0  LONG SetFileDate( STRPTR name, struct DateStamp *date );
; 30.121   0  LONG NameFromLock( BPTR lock, STRPTR buffer, long len );
; 30.122   0  LONG NameFromFH( BPTR fh, STRPTR buffer, long len );
; 30.123   0  WORD SplitName( STRPTR name, unsigned long seperator, STRPTR buf, long oldpos,
; 30.124   0  	long size );
; 30.125   0  LONG SameLock( BPTR lock1, BPTR lock2 );
; 30.126   0  LONG SetMode( BPTR fh, long mode );
; 30.127   0  LONG ExAll( BPTR lock, struct ExAllData *buffer, long size, long data,
; 30.128   0  	struct ExAllControl *control );
; 30.129   0  LONG ReadLink( struct MsgPort *port, BPTR lock, STRPTR path, STRPTR buffer,
; 30.130   0  	unsigned long size );
; 30.131   0  LONG MakeLink( STRPTR name, long dest, long soft );
; 30.132   0  LONG ChangeMode( long type, BPTR fh, long newmode );
; 30.133   0  LONG SetFileSize( BPTR fh, long pos, long mode );
; 30.134      /*	Error Handling */
; 30.135   0  LONG SetIoErr( long result );
; 30.136   0  BOOL Fault( long code, STRPTR header, STRPTR buffer, long len );
; 30.137   0  BOOL PrintFault( long code, STRPTR header );
; 30.138   0  LONG ErrorReport( long code, long type, unsigned long arg1,
; 30.139   0  	struct MsgPort *device );
; 30.140      /*	Process Management */
; 30.141   0  struct CommandLineInterface *Cli( void );
; 30.142   0  struct Process *CreateNewProc( struct TagItem *tags );
; 30.143   0  struct Process *CreateNewProcTagList( struct TagItem *tags );
; 30.144   0  struct Process *CreateNewProcTags( unsigned long tag1type, ... );
; 30.145   0  LONG RunCommand( BPTR seg, long stack, STRPTR paramptr, long paramlen );
; 30.146   0  struct MsgPort *GetConsoleTask( void );
; 30.147   0  struct MsgPort *SetConsoleTask( struct MsgPort *task );
; 30.148   0  struct MsgPort *GetFileSysTask( void );
; 30.149   0  struct MsgPort *SetFileSysTask( struct MsgPort *task );
; 30.150   0  STRPTR GetArgStr( void );
; 30.151   0  BOOL SetArgStr( STRPTR string );
; 30.152   0  struct Process *FindCliProc( unsigned long num );
; 30.153   0  ULONG MaxCli( void );
; 30.154   0  BOOL SetCurrentDirName( STRPTR name );
; 30.155   0  BOOL GetCurrentDirName( STRPTR buf, long len );
; 30.156   0  BOOL SetProgramName( STRPTR name );
; 30.157   0  BOOL GetProgramName( STRPTR buf, long len );
; 30.158   0  BOOL SetPrompt( STRPTR name );
; 30.159   0  BOOL GetPrompt( STRPTR buf, long len );
; 30.160   0  BPTR SetProgramDir( BPTR lock );
; 30.161   0  BPTR GetProgramDir( void );
; 30.162      /*	Device List Management */
; 30.163   0  LONG SystemTagList( STRPTR command, struct TagItem *tags );
; 30.164   0  LONG System( STRPTR command, struct TagItem *tags );
; 30.165   0  LONG SystemTags( STRPTR command, unsigned long tag1type, ... );
; 30.166   0  LONG AssignLock( STRPTR name, BPTR lock );

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 82
;
;
;Line#  Block                                  Source
; 30.167   0  BOOL AssignLate( STRPTR name, STRPTR path );
; 30.168   0  BOOL AssignPath( STRPTR name, STRPTR path );
; 30.169   0  BOOL AssignAdd( STRPTR name, BPTR lock );
; 30.170   0  LONG RemAssignList( STRPTR name, BPTR lock );
; 30.171   0  struct DevProc *GetDeviceProc( STRPTR name, struct DevProc *dp );
; 30.172   0  void FreeDeviceProc( struct DevProc *dp );
; 30.173   0  struct DosList *LockDosList( unsigned long flags );
; 30.174   0  void UnLockDosList( unsigned long flags );
; 30.175   0  struct DosList *AttemptLockDosList( unsigned long flags );
; 30.176   0  BOOL RemDosEntry( struct DosList *dlist );
; 30.177   0  LONG AddDosEntry( struct DosList *dlist );
; 30.178   0  struct DosList *FindDosEntry( struct DosList *dlist, STRPTR name,
; 30.179   0  	unsigned long flags );
; 30.180   0  struct DosList *NextDosEntry( struct DosList *dlist, unsigned long flags );
; 30.181   0  struct DosList *MakeDosEntry( STRPTR name, long type );
; 30.182   0  void FreeDosEntry( struct DosList *dlist );
; 30.183   0  BOOL IsFileSystem( STRPTR name );
; 30.184      /*	Handler Interface */
; 30.185   0  BOOL Format( STRPTR filesystem, STRPTR volumename, unsigned long dostype );
; 30.186   0  LONG Relabel( STRPTR drive, STRPTR newname );
; 30.187   0  LONG Inhibit( STRPTR name, long onoff );
; 30.188   0  LONG AddBuffers( STRPTR name, long number );
; 30.189      /*	Date, Time Routines */
; 30.190   0  LONG CompareDates( struct DateStamp *date1, struct DateStamp *date2 );
; 30.191   0  LONG DateToStr( struct DateTime *datetime );
; 30.192   0  LONG StrToDate( struct DateTime *datetime );
; 30.193      /*	Image Management */
; 30.194   0  BPTR InternalLoadSeg( BPTR fh, BPTR table, LONG *funcarray, LONG *stack );
; 30.195   0  BOOL InternalUnLoadSeg( BPTR seglist, void (*freefunc)() );
; 30.196   0  BPTR NewLoadSeg( STRPTR file, struct TagItem *tags );
; 30.197   0  BPTR NewLoadSegTagList( STRPTR file, struct TagItem *tags );
; 30.198   0  BPTR NewLoadSegTags( STRPTR file, unsigned long tag1type, ... );
; 30.199   0  LONG AddSegment( STRPTR name, BPTR seg, long system );
; 30.200   0  struct Segment *FindSegment( STRPTR name, struct Segment *seg, long system );
; 30.201   0  LONG RemSegment( struct Segment *seg );
; 30.202      /*	Command Support */
; 30.203   0  LONG CheckSignal( long mask );
; 30.204   0  struct RDArgs *ReadArgs( STRPTR arg_template, LONG *array,
; 30.205   0  	struct RDArgs *args );
; 30.206   0  LONG FindArg( STRPTR keyword, STRPTR arg_template );
; 30.207   0  LONG ReadItem( STRPTR name, long maxchars, struct CSource *cSource );
; 30.208   0  LONG StrToLong( STRPTR string, LONG *value );
; 30.209   0  LONG MatchFirst( STRPTR pat, struct AnchorPath *anchor );
; 30.210   0  LONG MatchNext( struct AnchorPath *anchor );
; 30.211   0  void MatchEnd( struct AnchorPath *anchor );
; 30.212   0  LONG ParsePattern( STRPTR pat, STRPTR buf, long buflen );
; 30.213   0  BOOL MatchPattern( STRPTR pat, STRPTR str );
; 30.214   0  void FreeArgs( struct RDArgs *args );
; 30.215   0  STRPTR FilePart( STRPTR path );
; 30.216   0  STRPTR PathPart( STRPTR path );

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 83
;
;
;Line#  Block                                  Source
; 30.217   0  BOOL AddPart( STRPTR dirname, STRPTR filename, unsigned long size );
; 30.218      /*	Notification */
; 30.219   0  BOOL StartNotify( struct NotifyRequest *notify );
; 30.220   0  void EndNotify( struct NotifyRequest *notify );
; 30.221      /*	Environment Variable functions */
; 30.222   0  BOOL SetVar( STRPTR name, STRPTR buffer, long size, long flags );
; 30.223   0  LONG GetVar( STRPTR name, STRPTR buffer, long size, long flags );
; 30.224   0  LONG DeleteVar( STRPTR name, unsigned long flags );
; 30.225   0  struct LocalVar *FindVar( STRPTR name, unsigned long type );
; 30.226   0  LONG CliInitNewcli( struct DosPacket *dp );
; 30.227   0  LONG CliInitRun( struct DosPacket *dp );
; 30.228   0  LONG WriteChars( STRPTR buf, unsigned long buflen );
; 30.229   0  LONG PutStr( STRPTR str );
; 30.230   0  LONG VPrintf( STRPTR format, APTR argarray );
; 30.231   0  LONG Printf( STRPTR format, ... );
; 30.232      /* these were unimplemented until dos 36.147 */
; 30.233   0  LONG ParsePatternNoCase( STRPTR pat, STRPTR buf, long buflen );
; 30.234   0  BOOL MatchPatternNoCase( STRPTR pat, STRPTR str );
; 30.235      /* this was added for V37 dos, returned 0 before then. */
; 30.236   0  BOOL SameDevice( BPTR lock1, BPTR lock2 );
; 30.237
; 30.238      /* NOTE: the following entries did NOT exist before ks 36.303 (2.02) */
; 30.239      /* If you are going to use them, open dos.library with version 37 */
; 30.240
; 30.241      /* These calls were added for V39 dos: */
; 30.242   0  void ExAllEnd( BPTR lock, struct ExAllData *buffer, long size, long data,
; 30.243   0  	struct ExAllControl *control );
; 30.244   0  BOOL SetOwner( STRPTR name, long owner_info );
; 30.245   0  #endif	 /* CLIB_DOS_PROTOS_H */
; 29.006   0  #include <pragmas/dos_pragmas.h>
;===> Including file "sc:include/pragmas/dos_pragmas.h"
; 41.023      /*pragma libcall DOSBase dosPrivate1 a2 0*/
; 41.024      /*pragma libcall DOSBase dosPrivate2 a8 0*/
; 41.034      /*--- functions in V36 or higher (Release 2.0) ---*/
; 41.035      /*	DOS Object creation/deletion*/
; 41.040      /*	Packet Level routines*/
; 41.046      /*	Record Locking*/
; 41.051      /*	Buffered File I/O*/
; 41.067      /*	DOS Object Management*/
; 41.083      /*	Error Handling*/
; 41.088      /*--- (1 function slot reserved here) ---*/
; 41.089      /*	Process Management*/
; 41.111      /*	Device List Management*/
; 41.132      /*	Handler Interface*/
; 41.137      /*	Date, Time Routines*/
; 41.141      /*	Image Management*/
; 41.150      /*	Command Support*/
; 41.161      /*pragma libcall DOSBase dosPrivate3 354 0*/
; 41.163      /*--- (1 function slot reserved here) ---*/
; 41.167      /*	Notification*/

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 84
;
;
;Line#  Block                                  Source
; 41.170      /*	Environment Variable functions*/
; 41.175      /*pragma libcall DOSBase dosPrivate4 39c 0*/
; 41.182      /*--- (1 function slot reserved here) ---*/
; 41.183      /* these were unimplemented until dos 36.147*/
; 41.186      /*pragma libcall DOSBase dosPrivate5 3d2 0*/
; 41.187      /* this was added for V37 dos, returned 0 before then.*/
; 41.189      /**/
; 41.190      /* NOTE: the following entries did NOT exist before ks 36.303 (2.02)*/
; 41.191      /* If you are going to use them, open dos.library with version 37*/
; 41.192      /**/
; 41.193      /* These calls were added for V39 dos:*/
; 41.196      /*--- (2 function slots reserved here) ---*/
; 41.197      /*--- (2 function slots reserved here) ---*/
; 41.198      /*--- (2 function slots reserved here) ---*/
; 41.199      /*--- (2 function slots reserved here) ---*/
; 29.007   0  #endif
; 14       0  #include "sxstructs.h"
;===> Including file "sc:include/sxstructs.h"
; 42.001
; 42.002   0  struct DoorsStruct
; 42.003   0  {
; 42.004   0  	char	chatdoor[52];
; 42.005   0  	UBYTE	chattype;
; 42.006   0  	char	msgdoor[52];
; 42.007   0  	UBYTE	msgtype;
; 42.008   0  	char	frontdoor[52];
; 42.009   0  	UBYTE	fronttype;
; 42.010   0  	char	msgdoorreply[52];
; 42.011   0  	UBYTE	msgdoorreplytype;
; 42.012   0  	char	nfdoor[52];
; 42.013   0  	UBYTE	nftype;
; 42.014   0  };
; 42.015
; 42.016   0  struct AccessStruct
; 42.017   0  {
; 42.018   0  	char name[32];
; 42.019   0  	UBYTE access;
; 42.020   0  	UBYTE flags;
; 42.021   0  	ULONG freefiles;
; 42.022   0  	ULONG freebytes;
; 42.023   0  	UWORD byteratio;
; 42.024   0  	UWORD fileratio;
; 42.025   0  	long Time_Limit;
; 42.026   0  	ULONG ConfAccess[10];
; 42.027   0  	char res[38];
; 42.028   0  };
; 42.029
; 42.030   0  struct MCPMessage
; 42.031   0  {
; 42.032   0  	struct Message Msg;

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 85
;
;
;Line#  Block                                  Source
; 42.033   0  	UWORD command;
; 42.034   0  	UWORD nodenum;
; 42.035   0  	long data1;
; 42.036   0  	long data2;
; 42.037   0  	long data3;
; 42.038   0  	long data4;
; 42.039   0  	long data5;
; 42.040   0  	char *action;
; 42.041   0  };
; 42.042
; 42.043   0  struct Flag
; 42.044   0  {
; 42.045   0  	struct Node flag_node;
; 42.046   0  	char path[72];
; 42.047   0  	char file[34];
; 42.048   0  	ULONG size;
; 42.049   0  	ULONG xfer;
; 42.050   0  	ULONG cps;
; 42.051   0  	UWORD secs;
; 42.052   0  	UWORD mins;
; 42.053   0  	UWORD hours;
; 42.054   0  	UBYTE conf;
; 42.055   0  	UBYTE area;
; 42.056   0  	UBYTE free;
; 42.057   0  	UBYTE misc;
; 42.058   0  };
; 42.059
; 42.060   0  struct MainStruct
; 42.061   0  {
; 42.062   0  	char BBSName[64];
; 42.063   0  	char USERPath[64];
; 42.064   0  	char BBSLoc[64];
; 42.065   0  	char Sysop[64];
; 42.066   0  	char DNPath[64];
; 42.067   0  	char ULPath[64];
; 42.068   0  	long nodes;
; 42.069   0  	UWORD inac_timeout;
; 42.070   0  	UWORD inac_warn;
; 42.071   0  };
; 42.072
; 42.073   0  struct SerialStruct
; 42.074   0  {
; 42.075   0  	char device[32];
; 42.076   0  	WORD unit;
; 42.077   0  	WORD misc;
; 42.078   0  	long minrate;
; 42.079   0  	long dcerate;
; 42.080   0  	UBYTE sevenwire;
; 42.081   0  	UBYTE shared;
; 42.082   0  	char ring[16];

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 86
;
;
;Line#  Block                                  Source
; 42.083   0  	char connect[24];
; 42.084   0  	char answer[16];
; 42.085   0  	char initstr[48];
; 42.086   0  };
; 42.087
; 42.088   0  struct ConfStruct
; 42.089   0  {
; 42.090   0  	char name[45];
; 42.091   0  	char path[55];
; 42.092   0  	char pass[16];
; 42.093   0  	char filepath[52];
; 42.094   0  	UWORD fileareas;
; 42.095   0  	UWORD uploadarea;
; 42.096   0  	UBYTE flf;
; 42.097   0  	UBYTE flags;
; 42.098   0  	char reserve[82];
; 42.099   0  };
; 42.100
; 42.101   0  struct SXUserStruct
; 42.102   0  {
; 42.103   0  	UWORD byteratio;
; 42.104   0  	UWORD fileratio;
; 42.105   0  	ULONG flags;
; 42.106   0  	UWORD freefiles;
; 42.107   0  	ULONG freebytes;
; 42.108   0  	ULONG ConfAccess[10];
; 42.109   0  	UWORD lastfilearea;
; 42.110   0  	char computer[24];
; 42.111   0  	char sentbyline[46];
; 42.112   0  	char password[16];
; 42.113   0  	long firstcall;
; 42.114   0  	char reserved[110];
; 42.115   0  };
; 42.116
; 42.117   0  struct UserData {
; 42.118   0  	char	Name[31],
; 42.119   0  		Pass[9],
; 42.120   0  		Location[30],
; 42.121   0  		PhoneNumber[13];
; 42.122   0  	USHORT	Slot_Number;
; 42.123   0  	USHORT	Sec_Status,
; 42.124   0  		Sec_Board,		/* File or Byte Ratio */
; 42.125   0  		Sec_Library,		/* Ratio              */
; 42.126   0  		Sec_Bulletin,		/* Computer Type      */
; 42.127   0  		Messages_Posted;
; 42.128   0  	ULONG	NewSinceDate,
; 42.129   0  		ConfRead1,
; 42.130   0  		ConfRead2,
; 42.131   0  		ConfRead3,
; 42.132   0  		ConfRead4,

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 87
;
;
;Line#  Block                                  Source
; 42.133   0  		ConfRead5,
; 42.134   0  		ConfRead6,
; 42.135   0  		ConfRead7,
; 42.136   0  		ConfRead8,
; 42.137   0  		ConfRead9;
; 42.138   0  	char	Conference_Access[10];
; 42.139   0  	USHORT	Uploads,
; 42.140   0  		Downloads,
; 42.141   0  		ConfRJoin,
; 42.142   0  		Times_Called;
; 42.143   0  	long	Time_Last_On,
; 42.144   0  		Time_Used,
; 42.145   0  		Time_Limit,
; 42.146   0  		Time_Left;
; 42.147   0  	ULONG	Bytes_Download,
; 42.148   0  		Bytes_Upload,
; 42.149   0  		Daily_Bytes_Limit,
; 42.150   0  		Daily_Bytes_Dld;
; 42.151   0  	char	Expert;
; 42.152   0  	ULONG	ConfYM1,
; 42.153   0  		ConfYM2,
; 42.154   0  		ConfYM3,
; 42.155   0  		ConfYM4,
; 42.156   0  		ConfYM5,
; 42.157   0  		ConfYM6,
; 42.158   0  		ConfYM7,
; 42.159   0  		ConfYM8,
; 42.160   0  		ConfYM9;
; 42.161   0  	long    BeginLogCall;
; 42.162   0  	UBYTE	Protocol,
; 42.163   0  		UUCPA,
; 42.164   0  		LineLength,
; 42.165   0  		Flags; 	/* BIT 0 = NEW USER		*/
; 42.166      			/*     1 = MAIL SCAN		*/
; 42.167      			/*     2 = MAIL SCAN ASK	*/
; 42.168      			/*     3 = FILE SCAN		*/
; 42.169      			/*     4 = FILE SCAN ASK	*/
; 42.170      			/*     5 = LINE MSG EDITOR	*/
; 42.171      			/*     6 = DELETED!		*/
; 42.172   0  	};
; 42.173
; 42.174   0  struct UserIndexStruct
; 42.175   0  {
; 42.176   0  	char handle[31];
; 42.177   0  	char realname[31];
; 42.178   0  	UBYTE flags; /* BIT 6 = DELETED!	*/
; 42.179   0  	UBYTE unused;
; 42.180   0  };
; 42.181
; 42.182   0  struct ArchiveStruct

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 88
;
;
;Line#  Block                                  Source
; 42.183   0  {
; 42.184   0  	char name[24];
; 42.185   0  	char patt[24];
; 42.186   0  	char testcmd[72];
; 42.187   0  	char unpackcmd[72];
; 42.188   0  	char packcmd[72];
; 42.189   0  	char viewcmd[72];
; 42.190   0  	char corrupt1[16];
; 42.191   0  	char corrupt2[16];
; 42.192   0  	char corrupt3[16];
; 42.193   0  	UBYTE flags;
; 42.194   0  	UBYTE viewaccess;
; 42.195   0  	char reserve[30];
; 42.196   0  };
; 42.197
; 42.198   0  struct ScreenModeStruct
; 42.199   0  {
; 42.200   0  	ULONG DisplayID;
; 42.201   0  	UWORD DisplayWidth;
; 42.202   0  	UWORD DisplayHeight;
; 42.203   0  	UWORD DisplayDepth;
; 42.204   0  	ULONG reserved;
; 42.205   0  	char fontname[32];
; 42.206   0  	UWORD fontsize;
; 42.207   0  	char device[32];
; 42.208   0  	WORD unit;
; 42.209   0  	ULONG flags;
; 42.210   0  };
; 42.211
; 42.212   0  struct DisplayStruct
; 42.213   0  {
; 42.214   0  	char name[16];
; 42.215   0  	char path[48];
; 42.216   0  	char ext[4];
; 42.217   0  	struct ScreenModeStruct ScreenMode;
; 42.218   0  	ULONG flags;
; 42.219   0  	char res[40];
; 42.220   0  };
; 42.221
; 42.222   0  struct ProtoStruct
; 42.223   0  {
; 42.224   0  	char name[24];
; 42.225   0  	char letter;
; 42.226   0  	char null;
; 42.227   0  	char type;
; 42.228   0  	char efficiency;
; 42.229   0  	char library[30];
; 42.230   0  	char initstr[30];
; 42.231   0  	char res[64];
; 42.232   0  };

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 89
;
;
;Line#  Block                                  Source
; 42.233
; 42.234   0  struct NodeStruct
; 42.235   0  {
; 42.236   0  	char systempass[16];
; 42.237   0  	char newuserpass[16];
; 42.238   0  	char fcheck[42];
; 42.239   0  	long flags;
; 42.240   0  };
; 15
; 16       0  struct MsgPort *bbsport;
; 17
; 18       0  struct JHMessage
; 19       0  {
; 20       0  	struct 	Message Msg;
; 21       0  	char	String[200];
; 22       0  	long	Data;
; 23       0  	long	Command;
; 24       0  } themsg;
; 25
; 26       0  struct XferLog
; 27       0  {
; 28       0          UWORD   user_slot;
; 29       0          UBYTE   conf,
; 30       0                  filearea;
; 31       0          char    filename[32];
; 32       0          long    size,
; 33       0                  baud,
; 34       0                  cps,
; 35       0                  time;
; 36       0          UBYTE   node;
; 37       0          char    res[7];
; 38       0  } XferLog;
; 39
; 40
; 41       0  void PS(char * str);
; 42       0  void XIMFunction(int func, long data, char * str);
; 43       0  void Nuke(char *fname);
; 44       0  void NukeFile(char *fname, char *dirbuf, long pos, long descsize, long bufsize);
; 45
; 46       0  char buf[512], listname[152];
; 47
; 48
; 49       0  void mysprintf(char *Buffer,char *ctl, ...)
; 50       0  {
; 51       1  	RawDoFmt(ctl, (long *)(&ctl + 1), (void (*))"\x16\xc0\x4e\x75", Buffer);
; 52       1  }
; 53
; 54       0  void myctime(long secs, char *outbuf)
; 55       0  {
; 56       1  	struct DateStamp *tp;

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 90
;
;
;Line#  Block                                  Source
; 57       1  	struct DateTime tostr;
; 58
; 59       1  	tp = __timecvt((time_t)secs);
; 60
; 61       1  	memcpy(&tostr, tp, 12);
; 62
; 63       1  	tostr.dat_Format  = FORMAT_DOS;
; 64       1  	tostr.dat_StrDay  = "DIGITAL   ";
; 65       1  	tostr.dat_StrDate = "CORRUPTION";
; 66       1  	tostr.dat_StrTime = "IN 1997!!";
; 67       1  	tostr.dat_Flags   = 0;
; 68
; 69       1  	DateToStr(&tostr);
; 70       1  	mysprintf(outbuf, "%s %s", tostr.dat_StrDate, tostr.dat_StrTime);
; 71       1  }
; 72
; 73       0  int main(int argc, char *argv[])
; 74       0  {
; 75       1  	if(!argv[1] || argv[1][0]==0)
; 76       1  		PutStr("This program requires System-X BBS Software\n");
; 77       1  	else {
; 78       2  		mysprintf(buf, "AEDoorPort%s", argv[1]);
; 79       2  		bbsport = FindPort(buf);
; 80       2  		if(bbsport)
; 81       2  		{
; 82       3  			XIMFunction(1, 0, 0); 	// function 1 = register
; 83
; 84       3  			PS("\r\n[0;36;44m SX-Nuke 1.05 BETA [0m\r\n");
; 85
; 86       3  			XIMFunction(1507, 0, 0);	// SX_ARG
; 87
; 88       3  			Nuke((char *)themsg.Data);
; 89
; 90       3  			XIMFunction(2, 0, 0); 	// function 2 = shutdown
; 91       3  		}
; 92       2  	}
; 93       1  }
; 94
; 95       0  void PS(char * str)
; 96       0  {
; 97       1  	XIMFunction(1500, (long)str, 0);
; 98       1  }
; 99
;100       0  void XIMFunction(int func, long data, char * str)
;101       0  {
;102       1  	struct MsgPort *replyport;
;103
;104       1  	replyport = CreateMsgPort();
;105       1  	if(replyport)
;106       1  	{

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 91
;
;
;Line#  Block                                  Source
;107       2  		themsg.Msg.mn_Length	= sizeof(struct JHMessage);
;108       2  		themsg.Msg.mn_ReplyPort	= replyport;
;109       2  		themsg.Data 		= data;
;110       2  		themsg.Command 		= func;
;111       2  		if(str && str[0]!=0) strcpy(themsg.String, str);
;112       2  		PutMsg(bbsport, (struct Message *)&themsg);
;113       2  		WaitPort(replyport);
;114       2  		DeleteMsgPort(replyport);
;115       2  	}
;116       1  }
;117
;118       0  long FindFile(char *dirbuf, long size, char *fname)
;119       0  {
;120       1  	char *po;
;121       1  	long i = 0;
;122
;123       1  	goto checkfile;
;124
;125       1  	while(i < size)
;126       1  	{
;127       2  		if(dirbuf[i] == 10)
;128       2  		{
;129       3  			i++;
;130       3  checkfile:
;131       3  			memcpy(buf, &dirbuf[i], 32);
;132       3  			po = strchr(buf, ' ');
;133       3  			if(po)
;134       3  			{
;135       4  				po[0] = 0;
;136       4  				if(stricmp(fname, buf)==0)
;137       4  					return(i);
;138       4  			}
;139       3  		}
;140       2  		i++;
;141       2  	}
;142       1  	return(-1);
;143       1  }
;144
;145       0  long DescSize(char *desc)
;146       0  {
;147       1  	register long i = 1;
;148
;149       1  	while(1)
;150       1  	{
;151       2  		if(desc[i] == 10)
;152       2  		{
;153       3  			i++;
;154       3  			if(desc[i] != ' ')
;155       3  			{
;156       4  				long a, b;

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 92
;
;
;Line#  Block                                  Source
;157
;158       4  				a = (long) desc;
;159       4  				b = (long) &desc[i];
;160
;161       4  				return(b - a);
;162       4  			}
;163       3  		}
;164       2  		if(desc[i] == 0) return(0);
;165       2  		i++;
;166       2  	}
;167       1  }
;168
;169       0  void Nuke(char *arg)
;170       0  {
;171       1  	BOOL found = FALSE;
;172       1  	BOOL done = FALSE;
;173       1  	char fname[32], *dirbuf;
;174       1  	UWORD dir = 0;
;175       1  	BPTR fh;
;176       1  	long size, pos, descsize;
;177
;178       1  	if(arg[0] == 0)
;179       1  	{
;180       2  		XIMFunction(5, 30, "\r\n[32mEnter filename[33m: [0m");
;181       2  		PS("\r\n");
;182       2  		strcpy(fname, themsg.String);
;183       2  	} else
;184       1  		strcpy(fname, arg);
;185
;186       1  	if(fname[0] == 0) return;
;187
;188       1  	XIMFunction(127, 1, 0);		// BB_CONFLOCAL
;189
;190       1  	while(!done)
;191       1  	{
;192       2  		dir++;
;193       2  		mysprintf(listname, "%sDir%ld", themsg.String, dir);
;194
;195       2  		fh = Open(listname, MODE_OLDFILE);
;196       2  		if(fh)
;197       2  		{
;198       3  			Seek(fh, 0, OFFSET_END);
;199       3  			size = Seek(fh, 0, OFFSET_BEGINNING);
;200
;201       3  			dirbuf = AllocMem(size+2, MEMF_PUBLIC|MEMF_CLEAR);
;202       3  			if(dirbuf)
;203       3  			{
;204       4  				Read(fh, dirbuf, size);
;205       4  				pos = FindFile(dirbuf, size, fname);
;206

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 93
;
;
;Line#  Block                                  Source
;207       4  				if(pos != -1)
;208       4  				{
;209       5  					descsize = DescSize(&dirbuf[pos]);
;210       5  					Close(fh);
;211       5  					fh = 0;
;212       5  					if(descsize)
;213       5  					{
;214       6  						NukeFile(fname, dirbuf, pos, descsize, size);
;215       6  						found = TRUE;
;216       6  					}
;217       5  					done = TRUE;
;218       5  				}
;219
;220       4  				FreeMem(dirbuf, size+2);
;221       4  			}
;222       3  			if(fh) Close(fh);
;223       3  		} else
;224       2  			done = TRUE;
;225       2  	}
;226
;227       1  	if(!found) PS("\r\nThat file cannot be found in this conference.\r\n\r\n");
;228       1  }
;229
;230       0  void RemoveFile(char *fname, char *dirbuf, long pos, long descsize, long bufsize
;       ..... )
;231       0  {
;232       1  	BPTR fh = Open(listname, MODE_NEWFILE);
;233       1  	if(fh)
;234       1  	{
;235       2  		long after;
;236
;237       2  		if(pos) Write(fh, dirbuf, pos);	// DATA BEFORE FILE
;238
;239       2  		after = pos + descsize;
;240
;241       2  		if(after != bufsize) Write(fh, &dirbuf[after], bufsize - after);	// DATA AFTER
;       .....  FILE
;242
;243       2  		Close(fh);
;244
;245       2  		PS("Filelist.... Altered.\r\n\r\n");
;246
;247       2  		XIMFunction(1511, 0, fname);	// SX_FINDFILE
;248
;249       2  		if(themsg.String[0])
;250       2  		{
;251       3  			strcpy(buf, themsg.String);
;252       3  			strcat(buf, fname);
;253       3  			DeleteFile(buf);
;254       3  			PS("File........ Deleted.");

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 94
;
;
;Line#  Block                                  Source
;255       3  		} else
;256       2  			PS("File........ Not Found.");
;257       2  	} else
;258       1  		PS("[0;31m\r\nCannot write to list - it might be in use.[0m\r\n");
;259       1  }
;260
;261       0  void TakeCredits(char *fname, char *dirbuf, long pos, long descsize, long bufsiz
;       ..... e, struct XferLog *Xfer)
;262       0  {
;263       1  	char *comment;
;264       1  	char tbuf[128];
;265       1  	struct UserData User;
;266       1  	struct UserData *ThisUser;
;267
;268       1  	BPTR ffh, fh = Open("SX:User.Data", MODE_OLDFILE);
;269       1  	if(fh)
;270       1  	{
;271       2  		Seek(fh, (Xfer->user_slot-1)*sizeof(struct UserData), OFFSET_BEGINNING);
;272       2  		Read(fh, &User, sizeof(struct UserData));
;273       2  		Seek(fh, (Xfer->user_slot-1)*sizeof(struct UserData), OFFSET_BEGINNING);
;274
;275       2  		mysprintf(buf,	"\r\n\r\n"
;276       2  				"[32mUploader      :[0m %s\r\n"
;277       2  				"[32mUploaded Files:[0m %ld\r\n"
;278       2  				"[32mUploaded Bytes:[0m %ld\r\n\r\n", User.Name, User.Uploads, User.Bytes_
;       ..... Upload);
;279       2  		PS(buf);
;280
;281       2  		XIMFunction(5, 40, "Take how many times credits (eg 1, 2): ");
;282
;283       2  		if(themsg.String[0])
;284       2  		{
;285       3  			UWORD factor = atoi(themsg.String);
;286       3  			mysprintf(buf,	"\r\n"
;287       3  					"[32mUploaded Files: [0m%-30ld [32mUploaded Bytes: [0m%ld\r\n"
;288       3  					"-    [32mDeduction: [0m%-30ld -    [32mDeduction: [0m%ld\r\n"
;289       3  					"[35m---------------------------                    ----------------------
;       ..... ------[0m\r\n"
;290       3  					"     [32mNew Value: [0m%-30ld      [32mNew Value: [0m%ld\r\n\r\n",
;291       3  						User.Uploads,
;292       3  						User.Bytes_Upload,
;293       3  						factor,
;294       3  						Xfer->size * factor,
;295       3  						User.Uploads - factor,
;296       3  						User.Bytes_Upload - (Xfer->size * factor));
;297       3  			PS(buf);
;298       3  			strcpy(themsg.String, "[36mIs this correct[32m([33mY[32m/[33mn[32m)[36
;       ..... m? [0m");
;299       3  getkey:
;300       3  			XIMFunction(6, 0, 0);		// 6 = JH_HK

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 95
;
;
;Line#  Block                                  Source
;301
;302       3  			switch(themsg.String[0])
;303       3  			{
;304       4  				case '\r':
;305       4  				case '\n':
;306       4  				case 'y':
;307       4  				case 'Y':
;308       4  					PS("Yes");
;309       4  askcom:
;310       4  					PS("\r\n\r\n[35m([36m1[35m)[0m Old\r\n"
;311       4  						"[35m([36m2[35m)[0m Fake\r\n"
;312       4  						"[35m([36m3[35m)[0m Shit\r\n"
;313       4  						"[35m([36m4[35m)[0m Other\r\n"
;314       4  						"[35m([36m5[35m)[0m No Comment\r\n\r\n"
;315       4  						"Select: ");
;316
;317       4  					themsg.String[0] = 0;
;318       4  					XIMFunction(6, 0, 0);	// 6 = JH_HK
;319
;320       4  					switch(themsg.String[0])
;321       4  					{
;322       5  						case '1':
;323       5  							comment = "OLD!";
;324       5  							break;
;325       5  						case '2':
;326       5  							comment = "FAKE!";
;327       5  							break;
;328       5  						case '3':
;329       5  							comment = "SHIT!";
;330       5  							break;
;331       5  						case '4':
;332       5  							XIMFunction(5, 20, "\r\n\r\nEnter comment: ");
;333       5  							if(themsg.String[0])
;334       5  							{
;335       6  								strcpy(tbuf, themsg.String);
;336       6  								comment = tbuf;
;337       6  							} else
;338       5  								comment = 0;
;339       5  							themsg.String[0] = ' ';
;340       5  							break;
;341       5  						case '5':
;342       5  							comment = 0;
;343       5  							break;
;344       5  						default:
;345       5  							goto askcom;
;346       5  					}
;347
;348       4  					themsg.String[1] = '\r';
;349       4  					themsg.String[2] = '\n';
;350       4  					themsg.String[3] = '\r';

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 96
;
;
;Line#  Block                                  Source
;351       4  					themsg.String[4] = '\n';
;352       4  					themsg.String[5] = 0;
;353       4  					PS(themsg.String);
;354
;355       4  					ffh = Open(listname, MODE_NEWFILE);
;356       4  					if(ffh)
;357       4  					{
;358       5  						long after = pos + descsize;
;359
;360       5  						dirbuf[pos+13] = ' ';
;361       5  						dirbuf[pos+14] = 'D';
;362       5  						dirbuf[pos+15] = 'E';
;363       5  						dirbuf[pos+16] = 'L';
;364       5  						dirbuf[pos+17] = 'E';
;365       5  						dirbuf[pos+18] = 'T';
;366       5  						dirbuf[pos+19] = 'E';
;367       5  						dirbuf[pos+20] = 'D';
;368
;369       5  						if(pos) Write(ffh, dirbuf, after);// DATA BEFORE FILE + FILE
;370
;371       5  						XIMFunction(1501, 0, 0);	// SX_USERPO
;372       5  						ThisUser = (struct UserData *) themsg.Data;
;373
;374       5  						if(comment)
;375       5  						{
;376       6  							mysprintf(buf, "                                 [32m%s[34m: [35m%s[0
;       ..... m\n", ThisUser->Name, comment);
;377       6  							Write(ffh, buf, strlen(buf));
;378       6  						}
;379
;380       5  						mysprintf(buf, "                                             [32m%ld* [3
;       ..... 1mCredits Taken[0m\n", factor);
;381       5  						Write(ffh, buf, strlen(buf));
;382
;383       5  						if(after != bufsize) Write(ffh, &dirbuf[after], bufsize - after);	// DATA
;       ..... AFTER FILE
;384
;385       5  						Close(ffh);
;386
;387       5  						PS("Filelist.... Altered.\r\n\r\n");
;388
;389       5  						XIMFunction(1511, 0, fname);	// SX_FINDFILE
;390
;391       5  						if(themsg.String[0])
;392       5  						{
;393       6  							strcpy(buf, themsg.String);
;394       6  							strcat(buf, fname);
;395       6  							DeleteFile(buf);
;396       6  							PS("File........ Deleted.");
;397       6  						} else

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 97
;
;
;Line#  Block                                  Source
;398       5  							PS("File........ Not Found.");
;399
;400       5  						User.Uploads -= factor;
;401       5  						User.Bytes_Upload -= Xfer->size * factor;
;402
;403       5  						Write(fh, &User, sizeof(struct UserData));
;404       5  						PS("\r\n\r\nAccount..... Saved.");
;405       5  					} else
;406       4  						PS("[0;31mCannot write to list - it might be in use.[0m\r\n");
;407       4  					break;
;408       4  				case 'n':
;409       4  				case 'N':
;410       4  					PS("No");
;411       4  					break;
;412       4  				default:
;413       4  					themsg.String[0] = 0;
;414       4  					goto getkey;
;415       4  			}
;416       3  		}
;417       2  		Close(fh);
;418       2  	}
;419       1  }
;420
;421       0  void Reward(char *fname, char *dirbuf, long pos, long descsize, long bufsize, st
;       ..... ruct XferLog *Xfer)
;422       0  {
;423       1  	struct UserData User;
;424
;425       1  	BPTR ffh, fh = Open("SX:User.Data", MODE_OLDFILE);
;426       1  	if(fh)
;427       1  	{
;428       2  		Seek(fh, (Xfer->user_slot-1)*sizeof(struct UserData), OFFSET_BEGINNING);
;429       2  		Read(fh, &User, sizeof(struct UserData));
;430       2  		Seek(fh, (Xfer->user_slot-1)*sizeof(struct UserData), OFFSET_BEGINNING);
;431
;432       2  		mysprintf(buf,	"\r\n\r\n"
;433       2  				"[32mUploader      :[0m %s\r\n"
;434       2  				"[32mUploaded Files:[0m %ld\r\n"
;435       2  				"[32mUploaded Bytes:[0m %ld\r\n\r\n", User.Name, User.Uploads, User.Bytes_
;       ..... Upload);
;436       2  		PS(buf);
;437
;438       2  		XIMFunction(5, 40, "Reward how many times credits (eg 1, 2): ");
;439
;440       2  		if(themsg.String[0])
;441       2  		{
;442       3  			UWORD factor = atoi(themsg.String);
;443       3  			mysprintf(buf,	"\r\n"
;444       3  					"[32mUploaded Files: [0m%-30ld [32mUploaded Bytes: [0m%ld\r\n"
;445       3  					"+       [32mReward: [0m%-30ld +    [32m   Reward: [0m%ld\r\n"

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 98
;
;
;Line#  Block                                  Source
;446       3  					"[35m---------------------------                    ----------------------
;       ..... ------[0m\r\n"
;447       3  					"     [32mNew Value: [0m%-30ld      [32mNew Value: [0m%ld\r\n\r\n",
;448       3  						User.Uploads,
;449       3  						User.Bytes_Upload,
;450       3  						factor,
;451       3  						Xfer->size * factor,
;452       3  						User.Uploads + factor,
;453       3  						User.Bytes_Upload + (Xfer->size * factor));
;454       3  			PS(buf);
;455       3  			strcpy(themsg.String, "[36mIs this correct[32m([33mY[32m/[33mn[32m)[36
;       ..... m? [0m");
;456       3  getkey:
;457       3  			XIMFunction(6, 0, 0);		// 6 = JH_HK
;458
;459       3  			switch(themsg.String[0])
;460       3  			{
;461       4  				case '\r':
;462       4  				case '\n':
;463       4  				case 'y':
;464       4  				case 'Y':
;465       4  					PS("Yes\r\n\r\n");
;466
;467       4  					ffh = Open(listname, MODE_NEWFILE);
;468       4  					if(ffh)
;469       4  					{
;470       5  						long after = pos + descsize;
;471
;472       5  						if(pos) Write(ffh, dirbuf, after);// DATA BEFORE FILE + FILE
;473
;474       5  						mysprintf(buf, "                                             [32m%ld* [3
;       ..... 3mCredits Given[0m\n", factor);
;475       5  						Write(ffh, buf, strlen(buf));
;476
;477       5  						if(after != bufsize) Write(ffh, &dirbuf[after], bufsize - after);	// DATA
;       ..... AFTER FILE
;478
;479       5  						Close(ffh);
;480
;481       5  						PS("Filelist.... Altered.");
;482
;483       5  						User.Uploads += factor;
;484       5  						User.Bytes_Upload += Xfer->size * factor;
;485
;486       5  						Write(fh, &User, sizeof(struct UserData));
;487       5  						PS("\r\n\r\nAccount..... Saved.");
;488       5  					} else
;489       4  						PS("[0;31mCannot write to list - it might be in use.[0m\r\n");
;490       4  					break;
;491       4  				case 'n':

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 99
;
;
;Line#  Block                                  Source
;492       4  				case 'N':
;493       4  					PS("No");
;494       4  					break;
;495       4  				default:
;496       4  					themsg.String[0] = 0;
;497       4  					goto getkey;
;498       4  			}
;499       3  		}
;500       2  		Close(fh);
;501       2  	}
;502       1  }
;503
;504       0  void NukeFile(char *fname, char *dirbuf, long pos, long descsize, long bufsize)
;505       0  {
;506       1  	struct UserData User;
;507       1  	struct XferLog Xfer;
;508       1  	BPTR fh;
;509       1  	WORD i, j = 0;
;510       1  	char timestr[32];
;511       1  	BOOL menu;
;512
;513       1  	PS("[0m\r\n");
;514
;515       1  	for(i=0 ; i<descsize ; i++)
;516       1  	{
;517       2  		if(dirbuf[pos+i] == 10)
;518       2  		{
;519       3  			buf[j] = 13;
;520       3  			j++;
;521       3  			buf[j] = 10;
;522       3  			j++;
;523       3  			buf[j] = 0;
;524       3  			PS(buf);
;525       3  			j = -1;
;526       3  		} else
;527       2  			buf[j] = dirbuf[pos+i];
;528
;529       2  		j++;
;530       2  	}
;531
;532       1  	PS("\r\n[32mSearching for uploader...[0m[A\r\n");
;533
;534       1  	fh = Open("SX:LogFiles/Upload.Log", MODE_OLDFILE);
;535       1  	if(fh)
;536       1  	{
;537       2  		while( Read(fh, &Xfer, sizeof(struct XferLog)) )
;538       2  		{
;539       3  			if(stricmp(fname, Xfer.filename) == 0)
;540       3  			{
;541       4  				Close(fh);

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 100
;
;
;Line#  Block                                  Source
;542       4  				goto find;
;543       4  			}
;544       3  		}
;545       2  		Close(fh);
;546       2  	}
;547       1  	PS("Uploader could not be found. File was Upped by the Sysop !\n\r");
;548       1  	Xfer.user_slot = 1;
;549
;550       1  find:
;551       1  	if(Xfer.user_slot != 0)
;552       1  	{
;553       2  		fh = Open("SX:User.Data", MODE_OLDFILE);
;554       2  		if(fh)
;555       2  		{
;556       3  			Seek(fh, (Xfer.user_slot-1)*sizeof(struct UserData), OFFSET_BEGINNING);
;557       3  			Read(fh, &User, sizeof(struct UserData));
;558       3  			Close(fh);
;559
;560       3  			myctime(Xfer.time, timestr);
;561
;562       3  			mysprintf(buf, "[32mUploader:[0m %s  [32mUpload Time:[0m %s  [32mCPS Rat
;       ..... e:[0m %ld\r\n\r\n", User.Name, timestr, Xfer.cps);
;563       3  			PS(buf);
;564       3  		}
;565       2  	}
;566       1  showmenu:
;567       1  	PS(	"[35m([36m1[35m)[0m Nuke file and take credits\r\n"
;568       1  		"[35m([36m5[35m)[0m Remove file from filelist and harddisk\r\n"
;569       1  		"[35m([36m9[35m)[0m Reward Uploader\r\n\r\n"
;570       1  		"[35m([36mQ[35m)[0m Quit and Abort\r\n"
;571       1  		"\r\n[36mSelect: [35m[[32m-[35m][0m[2D");
;572
;573       1  	do
;574       1  	{
;575       2  		menu = FALSE;
;576       2  		themsg.String[0] = 0;
;577       2  		XIMFunction(6, 0, 0);		// 6 = JH_HK
;578
;579       2  		if(themsg.Data == -1) break;	// LOST CARRIER
;580
;581       2  		PS(themsg.String);
;582
;583       2  		switch(themsg.String[0])
;584       2  		{
;585       3  		case '1':
;586       3  			if(Xfer.user_slot == 0)
;587       3  			{
;588       4  				menu = TRUE;
;589       4  				PS("\r\n\r\nUploader unknown - Cannot take credits.\r\n\r\n");
;590       4  				goto showmenu;

;SAS/C Amiga Compiler (Phase 1)  6.50                Jun 19 1998 10:02:58                                                                            Page 101
;
;
;Line#  Block                                  Source
;591       4  			} else
;592       3  				TakeCredits(fname, dirbuf, pos, descsize, bufsize, &Xfer);
;593       3  			break;
;594       3  		case '5':
;595       3  			RemoveFile(fname, dirbuf, pos, descsize, bufsize);
;596       3  			break;
;597       3  		case '9':
;598       3  			if(Xfer.user_slot == 0)
;599       3  			{
;600       4  				menu = TRUE;
;601       4  				PS("\r\n\r\nUploader unknown - Cannot reward.\r\n\r\n");
;602       4  				goto showmenu;
;603       4  			} else
;604       3  				Reward(fname, dirbuf, pos, descsize, bufsize, &Xfer);
;605       3  			break;
;606       3  		case 'q':
;607       3  		case 'Q':
;608       3  			break;
;609       3  		default:
;610       3  			PS("\b \b");
;611       3  			menu = TRUE;
;612       3  		}
;613       2  	}
;614       1  	while(menu);
;615
;616       1  	PS("\r\n\r\n");
;617       1  }
;618
6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 1


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE


__builtin_strlen near function returning "size_t"
                 AA-dev:FX-Nuke/sxnuke_II.c: 377, 381, 475

__builtin_strcpy near function returning pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 111, 182, 184, 251, 298, 335, 393,
                             455

__builtin_memcpy near function returning pointer to void
                 AA-dev:FX-Nuke/sxnuke_II.c: 61, 131

__timecvt        near function returning pointer to struct "DateStamp" (size 12
                 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 59

a                long
                 AA-dev:FX-Nuke/sxnuke_II.c: 156, 158, 161

after            long
                 AA-dev:FX-Nuke/sxnuke_II.c: 235, 239, 241(3)

after            long
                 AA-dev:FX-Nuke/sxnuke_II.c: 358, 369, 383(3)

after            long
                 AA-dev:FX-Nuke/sxnuke_II.c: 470, 472, 477(3)

arg              pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 169, 178, 184

argc             int
                 AA-dev:FX-Nuke/sxnuke_II.c: 73

argv             pointer to pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 78

argv             pointer to pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 73, 75(2)

askcom           label
                 AA-dev:FX-Nuke/sxnuke_II.c: 309, 345

atoi             near function returning int
                 AA-dev:FX-Nuke/sxnuke_II.c: 285, 442

AllocMem         near function returning "APTR"
                 AA-dev:FX-Nuke/sxnuke_II.c: 201

6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 2


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



b                long
                 AA-dev:FX-Nuke/sxnuke_II.c: 156, 159, 161

baud             long in struct "XferLog" (offset: 40)
                 AA-dev:FX-Nuke/sxnuke_II.c: 33

bbsport          pointer to struct "MsgPort"
                 AA-dev:FX-Nuke/sxnuke_II.c: 16, 79, 80, 112

buf              array [512] of char
                 AA-dev:FX-Nuke/sxnuke_II.c: 46, 78, 79, 131, 132, 136, 251, 252,
                             253, 275, 279, 286, 297, 376, 377(2), 380, 381(2),
                             393, 394, 395, 432, 436, 443, 454, 474, 475(2), 519,
                             521, 523, 524, 527, 562, 563

bufsize          long
                 AA-dev:FX-Nuke/sxnuke_II.c: 44

bufsize          long
                 AA-dev:FX-Nuke/sxnuke_II.c: 230, 241(2)

bufsize          long
                 AA-dev:FX-Nuke/sxnuke_II.c: 261, 383(2)

bufsize          long
                 AA-dev:FX-Nuke/sxnuke_II.c: 421, 477(2)

bufsize          long
                 AA-dev:FX-Nuke/sxnuke_II.c: 504, 592, 595, 604

BOOL             short
                 AA-dev:FX-Nuke/sxnuke_II.c: 171, 172, 511

BPTR             long
                 AA-dev:FX-Nuke/sxnuke_II.c: 175, 232, 268, 425, 508

Buffer           pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 49, 51

Bytes_Upload     unsigned long in struct "UserData" (offset: 174)
                 AA-dev:FX-Nuke/sxnuke_II.c: 278, 292, 296, 401, 435, 449, 453,
                             484

checkfile        label
                 AA-dev:FX-Nuke/sxnuke_II.c: 123, 130

comment          pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 323, 326, 329, 336, 338, 342, 374,
                             376

6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 3


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



comment          pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 263

conf             unsigned char in struct "XferLog" (offset: 2)
                 AA-dev:FX-Nuke/sxnuke_II.c: 29

cps              long in struct "XferLog" (offset: 44)
                 AA-dev:FX-Nuke/sxnuke_II.c: 34, 562

ctl              pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 49, 51(2)

Close            near function returning "LONG"
                 AA-dev:FX-Nuke/sxnuke_II.c: 210, 222, 243, 385, 417, 479, 500,
                             541, 545, 558

Command          long in struct "JHMessage" (offset: 224)
                 AA-dev:FX-Nuke/sxnuke_II.c: 23, 110

CreateMsgPort    near function returning pointer to struct "MsgPort" (size 34
                 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 104

dat_StrTime      pointer to unsigned char in enum <no tag> (offset: 22)
                 AA-dev:FX-Nuke/sxnuke_II.c: 70

dat_StrDate      pointer to unsigned char in enum <no tag> (offset: 18)
                 AA-dev:FX-Nuke/sxnuke_II.c: 70

dat_StrTime      pointer to unsigned char in struct "DateTime" (offset: 22)
                 AA-dev:FX-Nuke/sxnuke_II.c: 66

dat_StrDate      pointer to unsigned char in struct "DateTime" (offset: 18)
                 AA-dev:FX-Nuke/sxnuke_II.c: 65

dat_StrDay       pointer to unsigned char in struct "DateTime" (offset: 14)
                 AA-dev:FX-Nuke/sxnuke_II.c: 64

dat_Flags        unsigned char in struct "DateTime" (offset: 13)
                 AA-dev:FX-Nuke/sxnuke_II.c: 67

dat_Format       unsigned char in struct "DateTime" (offset: 12)
                 AA-dev:FX-Nuke/sxnuke_II.c: 63

data             long
                 AA-dev:FX-Nuke/sxnuke_II.c: 100, 109

6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 4


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



data             long
                 AA-dev:FX-Nuke/sxnuke_II.c: 42

desc             pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 151, 154, 158, 159, 164

descsize         long
                 AA-dev:FX-Nuke/sxnuke_II.c: 44

desc             pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 145

descsize         long
                 AA-dev:FX-Nuke/sxnuke_II.c: 176, 209, 212, 214

descsize         long
                 AA-dev:FX-Nuke/sxnuke_II.c: 230, 239

descsize         long
                 AA-dev:FX-Nuke/sxnuke_II.c: 261, 358

descsize         long
                 AA-dev:FX-Nuke/sxnuke_II.c: 421, 470

descsize         long
                 AA-dev:FX-Nuke/sxnuke_II.c: 504, 515, 592, 595, 604

dir              "UWORD"
                 AA-dev:FX-Nuke/sxnuke_II.c: 174, 192, 193

dirbuf           pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 44

dirbuf           pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 118, 127, 131

dirbuf           pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 173, 201, 202, 204, 205, 209, 214,
                             220

dirbuf           pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 230, 237, 241

dirbuf           pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 261, 360, 361, 362, 363, 364, 365,
                             366, 367, 369, 383

6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 5


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



dirbuf           pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 421, 472, 477

dirbuf           pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 504, 517, 527, 592, 595, 604

done             "BOOL"
                 AA-dev:FX-Nuke/sxnuke_II.c: 172, 190, 217, 224

DOSBase          pointer to struct "DosLibrary"
                 AA-dev:FX-Nuke/sxnuke_II.c: 69, 76, 195, 198, 199, 204, 210,
                             222, 232, 237, 241, 243, 253, 268, 271, 272, 273,
                             355, 369, 377, 381, 383, 385, 395, 403, 417, 425,
                             428, 429, 430, 467, 472, 475, 477, 479, 486, 500,
                             534, 537, 541, 545, 553, 556, 557, 558

Data             long in struct "JHMessage" (offset: 220)
                 AA-dev:FX-Nuke/sxnuke_II.c: 22, 88, 109, 372, 579

DateTime         struct tag (size 26 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 57
                 members:
                   dat_Stamp (offset: 0)
                   dat_Format (offset: 12)
                   dat_Flags (offset: 13)
                   dat_StrDay (offset: 14)
                   dat_StrDate (offset: 18)
                   dat_StrTime (offset: 22)

DateToStr        near function returning "LONG"
                 AA-dev:FX-Nuke/sxnuke_II.c: 69

DateStamp        struct tag (size 12 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 56
                 members:
                   ds_Days (offset: 0)
                   ds_Minute (offset: 4)
                   ds_Tick (offset: 8)

DeleteMsgPort    near function returning void
                 AA-dev:FX-Nuke/sxnuke_II.c: 114

DeleteFile       near function returning "LONG"
                 AA-dev:FX-Nuke/sxnuke_II.c: 253, 395

DescSize         near function returning long
                 AA-dev:FX-Nuke/sxnuke_II.c: 145, 209

6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 6


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



factor           "UWORD"
                 AA-dev:FX-Nuke/sxnuke_II.c: 285, 293, 294, 295, 296, 380, 400,
                             401

factor           "UWORD"
                 AA-dev:FX-Nuke/sxnuke_II.c: 442, 450, 451, 452, 453, 474, 483,
                             484

ffh              "BPTR"
                 AA-dev:FX-Nuke/sxnuke_II.c: 268, 355, 356, 369, 377, 381, 383,
                             385

ffh              "BPTR"
                 AA-dev:FX-Nuke/sxnuke_II.c: 425, 467, 468, 472, 475, 477, 479

fh               "BPTR"
                 AA-dev:FX-Nuke/sxnuke_II.c: 175, 195, 196, 198, 199, 204, 210,
                             211, 222(2)

fh               "BPTR"
                 AA-dev:FX-Nuke/sxnuke_II.c: 232, 233, 237, 241, 243

fh               "BPTR"
                 AA-dev:FX-Nuke/sxnuke_II.c: 268, 269, 271, 272, 273, 403, 417

fh               "BPTR"
                 AA-dev:FX-Nuke/sxnuke_II.c: 425, 426, 428, 429, 430, 486, 500

fh               "BPTR"
                 AA-dev:FX-Nuke/sxnuke_II.c: 508, 534, 535, 537, 541, 545, 553,
                             554, 556, 557, 558

filearea         unsigned char in struct "XferLog" (offset: 3)
                 AA-dev:FX-Nuke/sxnuke_II.c: 30

filename         array [32] of char in struct "XferLog" (offset: 4)
                 AA-dev:FX-Nuke/sxnuke_II.c: 31, 539

find             label
                 AA-dev:FX-Nuke/sxnuke_II.c: 542, 550

fname            pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 504, 539, 592, 595, 604

fname            pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 421

6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 7


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



fname            pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 230, 247, 252

fname            array [32] of char
                 AA-dev:FX-Nuke/sxnuke_II.c: 173, 182, 184, 186, 205, 214

fname            pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 118, 136

fname            pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 44

fname            pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 43

fname            pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 261, 389, 394

found            "BOOL"
                 AA-dev:FX-Nuke/sxnuke_II.c: 171, 215, 227

func             int
                 AA-dev:FX-Nuke/sxnuke_II.c: 100, 110

func             int
                 AA-dev:FX-Nuke/sxnuke_II.c: 42

FALSE            #define symbol
                 AA-dev:FX-Nuke/sxnuke_II.c: 171, 172, 575

FORMAT_DOS       #define symbol
                 AA-dev:FX-Nuke/sxnuke_II.c: 63

FindFile         near function returning long
                 AA-dev:FX-Nuke/sxnuke_II.c: 118, 205

FindPort         near function returning pointer to struct "MsgPort" (size 34
                 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 79

FreeMem          near function returning void
                 AA-dev:FX-Nuke/sxnuke_II.c: 220

getkey           label
                 AA-dev:FX-Nuke/sxnuke_II.c: 497

getkey           label
                 AA-dev:FX-Nuke/sxnuke_II.c: 299, 414

6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 8


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



getkey           label
                 AA-dev:FX-Nuke/sxnuke_II.c: 456

i                long
                 AA-dev:FX-Nuke/sxnuke_II.c: 121, 125, 127, 129, 131, 137, 140

i                long
                 AA-dev:FX-Nuke/sxnuke_II.c: 147, 151, 153, 154, 159, 164, 165

i                "WORD"
                 AA-dev:FX-Nuke/sxnuke_II.c: 509, 515(3), 517, 527

j                "WORD"
                 AA-dev:FX-Nuke/sxnuke_II.c: 509, 519, 520, 521, 522, 523, 525,
                             527, 529

JHMessage        struct tag (size 228 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 18, 107
                 members:
                   Msg (offset: 0)
                   String (offset: 20)
                   Data (offset: 220)
                   Command (offset: 224)

listname         array [152] of char
                 AA-dev:FX-Nuke/sxnuke_II.c: 46, 193, 195, 232, 355, 467

main             near function returning int
                 AA-dev:FX-Nuke/sxnuke_II.c: 73

memcpy           #define symbol  (3 arguments)
                 AA-dev:FX-Nuke/sxnuke_II.c: 61, 131

menu             "BOOL"
                 AA-dev:FX-Nuke/sxnuke_II.c: 511, 575, 588, 600, 611, 614

mn_Length        unsigned short in struct "Message" (offset: 18)
                 AA-dev:FX-Nuke/sxnuke_II.c: 107

mn_ReplyPort     pointer to struct "MsgPort" in struct "Message" (offset: 14)
                 AA-dev:FX-Nuke/sxnuke_II.c: 108

myctime          near function returning void
                 AA-dev:FX-Nuke/sxnuke_II.c: 54, 560

mysprintf        near __stdargs function returning void
                 AA-dev:FX-Nuke/sxnuke_II.c: 49, 70, 78, 193, 275, 286, 376, 380,
                             432, 443, 474, 562

6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 9


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



MEMF_PUBLIC      #define symbol
                 AA-dev:FX-Nuke/sxnuke_II.c: 201

MEMF_CLEAR       #define symbol
                 AA-dev:FX-Nuke/sxnuke_II.c: 201

MODE_OLDFILE     #define symbol
                 AA-dev:FX-Nuke/sxnuke_II.c: 534, 553

MODE_NEWFILE     #define symbol
                 AA-dev:FX-Nuke/sxnuke_II.c: 232, 355, 467

MODE_OLDFILE     #define symbol
                 AA-dev:FX-Nuke/sxnuke_II.c: 195, 268, 425

Message          struct tag (size 20 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 20, 112
                 members:
                   mn_Node (offset: 0)
                   mn_ReplyPort (offset: 14)
                   mn_Length (offset: 18)

Msg              struct "Message" (size 20 bytes) in struct "JHMessage" (offset:
                 0)
                 AA-dev:FX-Nuke/sxnuke_II.c: 20, 107, 108

MsgPort          struct tag (size 34 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 16, 102
                 members:
                   mp_Node (offset: 0)
                   mp_Flags (offset: 14)
                   mp_SigBit (offset: 15)
                   mp_SigTask (offset: 16)
                   mp_MsgList (offset: 20)

node             unsigned char in struct "XferLog" (offset: 52)
                 AA-dev:FX-Nuke/sxnuke_II.c: 36

Name             array [31] of char in struct "UserData" (offset: 0)
                 AA-dev:FX-Nuke/sxnuke_II.c: 278, 376, 435, 562

NukeFile         near function returning void
                 AA-dev:FX-Nuke/sxnuke_II.c: 504

Nuke             near function returning void
                 AA-dev:FX-Nuke/sxnuke_II.c: 169

6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 10


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



NukeFile         near function returning void
                 AA-dev:FX-Nuke/sxnuke_II.c: 44, 214

Nuke             near function returning void
                 AA-dev:FX-Nuke/sxnuke_II.c: 43, 88

outbuf           pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 54, 70

OFFSET_BEGINNING #define symbol
                 AA-dev:FX-Nuke/sxnuke_II.c: 199, 271, 273, 428, 430, 556

OFFSET_END       #define symbol
                 AA-dev:FX-Nuke/sxnuke_II.c: 198

Open             near function returning long
                 AA-dev:FX-Nuke/sxnuke_II.c: 268, 355, 425, 467, 534, 553

Open             near function returning "BPTR"
                 AA-dev:FX-Nuke/sxnuke_II.c: 195, 232

po               pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 120, 132, 133, 135

pos              long
                 AA-dev:FX-Nuke/sxnuke_II.c: 44

pos              long
                 AA-dev:FX-Nuke/sxnuke_II.c: 176, 205, 207, 209, 214

pos              long
                 AA-dev:FX-Nuke/sxnuke_II.c: 230, 237(2), 239

pos              long
                 AA-dev:FX-Nuke/sxnuke_II.c: 261, 358, 360, 361, 362, 363, 364,
                             365, 366, 367, 369

pos              long
                 AA-dev:FX-Nuke/sxnuke_II.c: 421, 470, 472

pos              long
                 AA-dev:FX-Nuke/sxnuke_II.c: 504, 517, 527, 592, 595, 604

PS               near function returning void
                 AA-dev:FX-Nuke/sxnuke_II.c: 41, 84, 95, 181, 227, 245, 254, 256,
                             258, 279, 297, 308, 310, 353, 387, 396, 398, 404,
                             406, 410, 436, 454, 465, 481, 487, 489, 493, 513,
                             524, 532, 547, 563, 567, 581, 589, 601, 610, 616

6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 11


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



PutMsg           near function returning void
                 AA-dev:FX-Nuke/sxnuke_II.c: 112

PutStr           near function returning "LONG"
                 AA-dev:FX-Nuke/sxnuke_II.c: 76

replyport        pointer to struct "MsgPort"
                 AA-dev:FX-Nuke/sxnuke_II.c: 102, 104, 105, 108, 113, 114

res              array [7] of char in struct "XferLog" (offset: 53)
                 AA-dev:FX-Nuke/sxnuke_II.c: 37

RawDoFmt         near function returning "APTR"
                 AA-dev:FX-Nuke/sxnuke_II.c: 51

Read             near function returning long
                 AA-dev:FX-Nuke/sxnuke_II.c: 204, 272, 429, 537, 557

RemoveFile       near function returning void
                 AA-dev:FX-Nuke/sxnuke_II.c: 230, 595

Reward           near function returning void
                 AA-dev:FX-Nuke/sxnuke_II.c: 421, 604

secs             long
                 AA-dev:FX-Nuke/sxnuke_II.c: 54, 59

showmenu         label
                 AA-dev:FX-Nuke/sxnuke_II.c: 566, 590, 602

size             long in enum <no tag> (offset: 36)
                 AA-dev:FX-Nuke/sxnuke_II.c: 401, 451, 453, 484

size             long
                 AA-dev:FX-Nuke/sxnuke_II.c: 176, 199, 201, 204, 205, 214, 220

size             long
                 AA-dev:FX-Nuke/sxnuke_II.c: 118, 125

size             long in struct "XferLog" (offset: 36)
                 AA-dev:FX-Nuke/sxnuke_II.c: 32, 294, 296

str              pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 41

str              pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 42

6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 12


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



str              pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 95, 97

str              pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 100, 111(3)

strcat           near function returning pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 252, 394

strchr           near function returning pointer to char
                 AA-dev:FX-Nuke/sxnuke_II.c: 132

strcpy           #define symbol  (2 arguments)
                 AA-dev:FX-Nuke/sxnuke_II.c: 111, 182, 184, 251, 298, 335, 393,
                             455

stricmp          near function returning int
                 AA-dev:FX-Nuke/sxnuke_II.c: 136, 539

strlen           #define symbol  (1 argument)
                 AA-dev:FX-Nuke/sxnuke_II.c: 377, 381, 475

Seek             near function returning "LONG"
                 AA-dev:FX-Nuke/sxnuke_II.c: 198, 199, 271, 273, 428, 430, 556

String           array [200] of char in struct "JHMessage" (offset: 20)
                 AA-dev:FX-Nuke/sxnuke_II.c: 21, 111, 182, 193, 249, 251, 283,
                             285, 298, 302, 317, 320, 333, 335, 339, 348, 349,
                             350, 351, 352, 353, 391, 393, 413, 440, 442, 455,
                             459, 496, 576, 581, 583

SysBase          pointer to struct "ExecBase"
                 AA-dev:FX-Nuke/sxnuke_II.c: 51, 79, 104, 112, 113, 114, 201,
                             220

tbuf             array [128] of char
                 AA-dev:FX-Nuke/sxnuke_II.c: 264, 335, 336

themsg           struct "JHMessage" (size 228 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 24, 88, 107, 108, 109, 110, 111,
                             112, 182, 193, 249, 251, 283, 285, 298, 302, 317,
                             320, 333, 335, 339, 348, 349, 350, 351, 352, 353,
                             372, 391, 393, 413, 440, 442, 455, 459, 496, 576,
                             579, 581, 583

time             long in enum <no tag> (offset: 48)
                 AA-dev:FX-Nuke/sxnuke_II.c: 560

6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 13


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



time_t           long
                 AA-dev:FX-Nuke/sxnuke_II.c: 59

time             long in struct "XferLog" (offset: 48)
                 AA-dev:FX-Nuke/sxnuke_II.c: 35

timestr          array [32] of char
                 AA-dev:FX-Nuke/sxnuke_II.c: 510, 560, 562

tostr            struct "DateTime" (size 26 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 57, 61, 63, 64, 65, 66, 67, 69,
                             70(2)

tp               pointer to struct "DateStamp"
                 AA-dev:FX-Nuke/sxnuke_II.c: 56, 59, 61

TRUE             #define symbol
                 AA-dev:FX-Nuke/sxnuke_II.c: 215, 217, 224, 588, 600, 611

TakeCredits      near function returning void
                 AA-dev:FX-Nuke/sxnuke_II.c: 261, 592

ThisUser         pointer to struct "UserData"
                 AA-dev:FX-Nuke/sxnuke_II.c: 266, 372, 376

user_slot        unsigned short in struct "XferLog" (offset: 0)
                 AA-dev:FX-Nuke/sxnuke_II.c: 28, 271, 273, 428, 430, 548, 551,
                             556, 586, 598

UBYTE            unsigned char
                 AA-dev:FX-Nuke/sxnuke_II.c: 29, 36

UWORD            unsigned short
                 AA-dev:FX-Nuke/sxnuke_II.c: 28, 174, 285, 442

Uploads          unsigned short in struct "UserData" (offset: 146)
                 AA-dev:FX-Nuke/sxnuke_II.c: 278, 291, 295, 400, 435, 448, 452,
                             483

User             struct "UserData" (size 232 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 562

UserData         struct tag (size 232 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 557
                 members:
                   Name (offset: 0)
                   Pass (offset: 31)
                   Location (offset: 40)
                   PhoneNumber (offset: 70)
6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 14


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



                   Slot_Number (offset: 84)
                   Sec_Status (offset: 86)
                   Sec_Board (offset: 88)
                   Sec_Library (offset: 90)
                   Sec_Bulletin (offset: 92)
                   Messages_Posted (offset: 94)
                   NewSinceDate (offset: 96)
                   ConfRead1 (offset: 100)
                   ConfRead2 (offset: 104)
                   ConfRead3 (offset: 108)
                   ConfRead4 (offset: 112)
                   ConfRead5 (offset: 116)
                   ConfRead6 (offset: 120)
                   ConfRead7 (offset: 124)
                   ConfRead8 (offset: 128)
                   ConfRead9 (offset: 132)
                   Conference_Access (offset: 136)
                   Uploads (offset: 146)
                   Downloads (offset: 148)
                   ConfRJoin (offset: 150)
                   Times_Called (offset: 152)
                   Time_Last_On (offset: 154)
                   Time_Used (offset: 158)
                   Time_Limit (offset: 162)
                   Time_Left (offset: 166)
                   Bytes_Download (offset: 170)
                   Bytes_Upload (offset: 174)
                   Daily_Bytes_Limit (offset: 178)
                   Daily_Bytes_Dld (offset: 182)
                   Expert (offset: 186)
                   ConfYM1 (offset: 188)
                   ConfYM2 (offset: 192)
                   ConfYM3 (offset: 196)
                   ConfYM4 (offset: 200)
                   ConfYM5 (offset: 204)
                   ConfYM6 (offset: 208)
                   ConfYM7 (offset: 212)
                   ConfYM8 (offset: 216)
                   ConfYM9 (offset: 220)
                   BeginLogCall (offset: 224)
                   Protocol (offset: 228)
                   UUCPA (offset: 229)
                   LineLength (offset: 230)
                   Flags (offset: 231)

User             struct "UserData" (size 232 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 557

6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 15


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



UserData         struct tag (size 232 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 556
                 members:
                   Name (offset: 0)
                   Pass (offset: 31)
                   Location (offset: 40)
                   PhoneNumber (offset: 70)
                   Slot_Number (offset: 84)
                   Sec_Status (offset: 86)
                   Sec_Board (offset: 88)
                   Sec_Library (offset: 90)
                   Sec_Bulletin (offset: 92)
                   Messages_Posted (offset: 94)
                   NewSinceDate (offset: 96)
                   ConfRead1 (offset: 100)
                   ConfRead2 (offset: 104)
                   ConfRead3 (offset: 108)
                   ConfRead4 (offset: 112)
                   ConfRead5 (offset: 116)
                   ConfRead6 (offset: 120)
                   ConfRead7 (offset: 124)
                   ConfRead8 (offset: 128)
                   ConfRead9 (offset: 132)
                   Conference_Access (offset: 136)
                   Uploads (offset: 146)
                   Downloads (offset: 148)
                   ConfRJoin (offset: 150)
                   Times_Called (offset: 152)
                   Time_Last_On (offset: 154)
                   Time_Used (offset: 158)
                   Time_Limit (offset: 162)
                   Time_Left (offset: 166)
                   Bytes_Download (offset: 170)
                   Bytes_Upload (offset: 174)
                   Daily_Bytes_Limit (offset: 178)
                   Daily_Bytes_Dld (offset: 182)
                   Expert (offset: 186)
                   ConfYM1 (offset: 188)
                   ConfYM2 (offset: 192)
                   ConfYM3 (offset: 196)
                   ConfYM4 (offset: 200)
                   ConfYM5 (offset: 204)
                   ConfYM6 (offset: 208)
                   ConfYM7 (offset: 212)
                   ConfYM8 (offset: 216)
                   ConfYM9 (offset: 220)
                   BeginLogCall (offset: 224)
                   Protocol (offset: 228)
                   UUCPA (offset: 229)
6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 16


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



                   LineLength (offset: 230)
                   Flags (offset: 231)

User             struct "UserData" (size 232 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 506

User             struct "UserData" (size 232 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 423, 429, 435(3), 448, 449, 452,
                             453, 483, 484, 486

UserData         struct tag (size 232 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 272, 273, 372, 403, 423, 428, 429,
                             430, 486, 506
                 members:
                   Name (offset: 0)
                   Pass (offset: 31)
                   Location (offset: 40)
                   PhoneNumber (offset: 70)
                   Slot_Number (offset: 84)
                   Sec_Status (offset: 86)
                   Sec_Board (offset: 88)
                   Sec_Library (offset: 90)
                   Sec_Bulletin (offset: 92)
                   Messages_Posted (offset: 94)
                   NewSinceDate (offset: 96)
                   ConfRead1 (offset: 100)
                   ConfRead2 (offset: 104)
                   ConfRead3 (offset: 108)
                   ConfRead4 (offset: 112)
                   ConfRead5 (offset: 116)
                   ConfRead6 (offset: 120)
                   ConfRead7 (offset: 124)
                   ConfRead8 (offset: 128)
                   ConfRead9 (offset: 132)
                   Conference_Access (offset: 136)
                   Uploads (offset: 146)
                   Downloads (offset: 148)
                   ConfRJoin (offset: 150)
                   Times_Called (offset: 152)
                   Time_Last_On (offset: 154)
                   Time_Used (offset: 158)
                   Time_Limit (offset: 162)
                   Time_Left (offset: 166)
                   Bytes_Download (offset: 170)
                   Bytes_Upload (offset: 174)
                   Daily_Bytes_Limit (offset: 178)
                   Daily_Bytes_Dld (offset: 182)
                   Expert (offset: 186)
                   ConfYM1 (offset: 188)
6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 17


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



                   ConfYM2 (offset: 192)
                   ConfYM3 (offset: 196)
                   ConfYM4 (offset: 200)
                   ConfYM5 (offset: 204)
                   ConfYM6 (offset: 208)
                   ConfYM7 (offset: 212)
                   ConfYM8 (offset: 216)
                   ConfYM9 (offset: 220)
                   BeginLogCall (offset: 224)
                   Protocol (offset: 228)
                   UUCPA (offset: 229)
                   LineLength (offset: 230)
                   Flags (offset: 231)

User             struct "UserData" (size 232 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 272, 278(3), 291, 292, 295, 296,
                             400, 401, 403

UserData         struct tag (size 232 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 271
                 members:
                   Name (offset: 0)
                   Pass (offset: 31)
                   Location (offset: 40)
                   PhoneNumber (offset: 70)
                   Slot_Number (offset: 84)
                   Sec_Status (offset: 86)
                   Sec_Board (offset: 88)
                   Sec_Library (offset: 90)
                   Sec_Bulletin (offset: 92)
                   Messages_Posted (offset: 94)
                   NewSinceDate (offset: 96)
                   ConfRead1 (offset: 100)
                   ConfRead2 (offset: 104)
                   ConfRead3 (offset: 108)
                   ConfRead4 (offset: 112)
                   ConfRead5 (offset: 116)
                   ConfRead6 (offset: 120)
                   ConfRead7 (offset: 124)
                   ConfRead8 (offset: 128)
                   ConfRead9 (offset: 132)
                   Conference_Access (offset: 136)
                   Uploads (offset: 146)
                   Downloads (offset: 148)
                   ConfRJoin (offset: 150)
                   Times_Called (offset: 152)
                   Time_Last_On (offset: 154)
                   Time_Used (offset: 158)
                   Time_Limit (offset: 162)
6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 18


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



                   Time_Left (offset: 166)
                   Bytes_Download (offset: 170)
                   Bytes_Upload (offset: 174)
                   Daily_Bytes_Limit (offset: 178)
                   Daily_Bytes_Dld (offset: 182)
                   Expert (offset: 186)
                   ConfYM1 (offset: 188)
                   ConfYM2 (offset: 192)
                   ConfYM3 (offset: 196)
                   ConfYM4 (offset: 200)
                   ConfYM5 (offset: 204)
                   ConfYM6 (offset: 208)
                   ConfYM7 (offset: 212)
                   ConfYM8 (offset: 216)
                   ConfYM9 (offset: 220)
                   BeginLogCall (offset: 224)
                   Protocol (offset: 228)
                   UUCPA (offset: 229)
                   LineLength (offset: 230)
                   Flags (offset: 231)

User             struct "UserData" (size 232 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 265

UserData         struct tag (size 232 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 265, 266
                 members:
                   Name (offset: 0)
                   Pass (offset: 31)
                   Location (offset: 40)
                   PhoneNumber (offset: 70)
                   Slot_Number (offset: 84)
                   Sec_Status (offset: 86)
                   Sec_Board (offset: 88)
                   Sec_Library (offset: 90)
                   Sec_Bulletin (offset: 92)
                   Messages_Posted (offset: 94)
                   NewSinceDate (offset: 96)
                   ConfRead1 (offset: 100)
                   ConfRead2 (offset: 104)
                   ConfRead3 (offset: 108)
                   ConfRead4 (offset: 112)
                   ConfRead5 (offset: 116)
                   ConfRead6 (offset: 120)
                   ConfRead7 (offset: 124)
                   ConfRead8 (offset: 128)
                   ConfRead9 (offset: 132)
                   Conference_Access (offset: 136)
                   Uploads (offset: 146)
6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 19


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



                   Downloads (offset: 148)
                   ConfRJoin (offset: 150)
                   Times_Called (offset: 152)
                   Time_Last_On (offset: 154)
                   Time_Used (offset: 158)
                   Time_Limit (offset: 162)
                   Time_Left (offset: 166)
                   Bytes_Download (offset: 170)
                   Bytes_Upload (offset: 174)
                   Daily_Bytes_Limit (offset: 178)
                   Daily_Bytes_Dld (offset: 182)
                   Expert (offset: 186)
                   ConfYM1 (offset: 188)
                   ConfYM2 (offset: 192)
                   ConfYM3 (offset: 196)
                   ConfYM4 (offset: 200)
                   ConfYM5 (offset: 204)
                   ConfYM6 (offset: 208)
                   ConfYM7 (offset: 212)
                   ConfYM8 (offset: 216)
                   ConfYM9 (offset: 220)
                   BeginLogCall (offset: 224)
                   Protocol (offset: 228)
                   UUCPA (offset: 229)
                   LineLength (offset: 230)
                   Flags (offset: 231)

WORD             short
                 AA-dev:FX-Nuke/sxnuke_II.c: 509

WaitPort         near function returning pointer to struct "Message" (size 20
                 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 113

Write            near function returning long
                 AA-dev:FX-Nuke/sxnuke_II.c: 369, 377, 381, 383, 403, 472, 475,
                             477, 486

Write            near function returning "LONG"
                 AA-dev:FX-Nuke/sxnuke_II.c: 237, 241

XIMFunction      near function returning void
                 AA-dev:FX-Nuke/sxnuke_II.c: 42, 82, 86, 90, 97, 100, 180, 188,
                             247, 281, 300, 318, 332, 371, 389, 438, 457, 577

Xfer             struct "XferLog" (size 60 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 551, 556, 560, 562, 586, 592, 598,
                             604

6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 20


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



XferLog          struct tag (size 60 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 537
                 members:
                   user_slot (offset: 0)
                   conf (offset: 2)
                   filearea (offset: 3)
                   filename (offset: 4)
                   size (offset: 36)
                   baud (offset: 40)
                   cps (offset: 44)
                   time (offset: 48)
                   node (offset: 52)
                   res (offset: 53)

Xfer             struct "XferLog" (size 60 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 507, 537, 539, 548

Xfer             pointer to struct "XferLog"
                 AA-dev:FX-Nuke/sxnuke_II.c: 421, 428, 430, 451, 453, 484

XferLog          struct tag (size 60 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 421, 507
                 members:
                   user_slot (offset: 0)
                   conf (offset: 2)
                   filearea (offset: 3)
                   filename (offset: 4)
                   size (offset: 36)
                   baud (offset: 40)
                   cps (offset: 44)
                   time (offset: 48)
                   node (offset: 52)
                   res (offset: 53)

Xfer             pointer to struct "XferLog"
                 AA-dev:FX-Nuke/sxnuke_II.c: 273, 294, 296, 401

XferLog          struct tag (size 60 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 261
                 members:
                   user_slot (offset: 0)
                   conf (offset: 2)
                   filearea (offset: 3)
                   filename (offset: 4)
                   size (offset: 36)
                   baud (offset: 40)
                   cps (offset: 44)
                   time (offset: 48)
                   node (offset: 52)
6.50 (Cross Reference)        Jun 19 1998 10:03:19                         Page 21


      SYMBOL        ATTRIBUTES AND CROSS REFERENCE



                   res (offset: 53)

XferLog          struct "XferLog" (size 60 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 38

XferLog          struct tag (size 60 bytes)
                 AA-dev:FX-Nuke/sxnuke_II.c: 26
                 members:
                   user_slot (offset: 0)
                   conf (offset: 2)
                   filearea (offset: 3)
                   filename (offset: 4)
                   size (offset: 36)
                   baud (offset: 40)
                   cps (offset: 44)
                   time (offset: 48)
                   node (offset: 52)
                   res (offset: 53)

Xfer             pointer to struct "XferLog"
                 AA-dev:FX-Nuke/sxnuke_II.c: 261, 271
